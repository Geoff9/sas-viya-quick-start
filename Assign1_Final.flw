/*===========================================================================*
* Flow:         Assign51d.flw
* ID:           
* Created:      2025-06-29T10:20:56.879773757Z
* Created by:   geoffrey.brands@student.torrens.edu.au
* Modified:     2025-06-29T10:20:56.879773757Z
* Modified by:  geoffrey.brands@student.torrens.edu.au
*
* Output Tables:
*   WORK.Final
*
* Version:       DataFlows lts 2024.09 (20250113.1736793992259)
*
* Generated On:  2025-06-29T10:20:56.879773757Z
* Generated by:  geoffrey.brands@student.torrens.edu.au
*============================================================================*/
/* region: Generated preamble */

/* Make sure the current directory is writable */
data _null_;
    length rc 4;
    %let tworkloc="%sysfunc(getoption(work))";
    rc=dlgcdir(&tworkloc);
run;

/* Setup options */
title;
footnote;
options validvarname=any;
options validmemname=extend;
options dtreset date number;
options device=png;

/* Setup macro variables */
%let syscc=0;
%let _clientapp = %nrquote(%nrstr(SAS Studio));
%let _clientappabbrev = %nrquote(%nrstr(Studio));
%let _clientappversion=2024.09;
%let _clientversion=6.1054.31;
%let _sasservername=&SYSHOSTNAME;
%let _sashostname=&SYSHOSTNAME;
%let _sasprogramfilehost=&SYSHOSTNAME;
%let _clientuserid = %nrquote(%nrstr(geoffrey.brands@student.torrens.edu.au));
%let _clientusername = %nrquote(%nrstr(geoffrey.brands@student.torrens.edu.au));
%let clientmachine = %nrquote(%nrstr());
%let _clientmachine = %nrquote(%nrstr());
%let _clientmode = %nrquote(%nrstr(viya));
%let sasworklocation="%sysfunc(getoption(work))/";
filename _cwd &sasworklocation;
data _null_;
    call symput('_sasworkingdir',pathname('_cwd'));
run;
filename _cwd;
%let _sasprogramfile = %nrquote(%nrstr());
%let _baseurl = %nrquote(%nrstr(https://vfl-027.engage.sas.com/SASStudio/));
%let _execenv = %nrquote(%nrstr(SASStudio;));
%symdel _dataout_mime_type _dataout_name _dataout_url _dataout_table / nowarn;
%let _sasws_ = %bquote(%sysfunc(getoption(work)));
%let _saswstemp_ = %bquote(%sysfunc(getoption(work)));

/* Detect SAS/Graph and setup graph options */
data _null_;
    length rc $255;
    call symput("graphinit","");
    call symput("graphterm","");
    rc=tslvl('sasxgopt','n');
    _error_=0;
    if (rc^=' ') then do;
        call symput("graphinit","goptions reset=all gsfname=_gsfname;");
        call symput("graphterm","goptions noaccessible;");
    end;
run;
data _null_;
    length rc 4;
    rc=sysprod("PRODNUM002");
    if (rc^=1) then do;
        call symput("graphinit","");
        call symput("graphterm","");
    end;
run;

/* Setup ODS destinations */
ods _all_ close;
filename _htmlout temp;
filename _listout temp;
filename _gsfname temp;
filename _dataout temp;
ods autonavigate off;
ods graphics on;
ods html5 (id=web) METATEXT='http-equiv="Content-Security-Policy" content="default-src ''none''; style-src ''unsafe-inline''; img-src data: ;"' device=png gpath="&_saswstemp_" path="&_saswstemp_" encoding=utf8 file=_htmlout (title='Results:Assign51d.flw') style=Illuminate options(bitmap_mode='inline' outline='on' svg_mode='inline' css_prefix='.ods_d647ae0a-9935-49b6-a133-8f741d3acf28' body_id='div_d647ae0a-9935-49b6-a133-8f741d3acf28' );
ods listing file=_listout;
&graphinit;

/* endregion */

/* region: Generated flow setup */
%let flow_id = ;
%let flow_name = Assign51d.flw;
%let flow_place = ;
%let flow_location = ;
%macro _flw_action_start(nodes);
    data _null_;
        dtEndStr = put(datetime(), E8601DZ.);
        put "_FLW_ACTION_START_|" dtEndStr +(-1) "|&nodes";
    run;
%mend _flw_action_start;
%macro _flw_action_end(nodes, table_libs, libs, table_names);
    data _null_;

        attrib next_table_name length = $32 informat = $32. format = $32.
               dtStartStr length = $26 informat = $26. format = $26.;

        %local i next_table;
        %do i=1 %to %sysfunc(countc(&table_libs, |)) + 1;
            %let next_table = %qscan(&table_libs, &i, |);
            %let next_lib = %qscan(&libs, &i, |);
            %let next_table_name = %qscan(&table_names, &i, |);
            next_table_name = kreverse(ksubstr(kreverse(ksubstr(kstrip("&next_table_name."),2)),2));
            %let table_exists = %eval(%sysfunc(exist(&next_table, data)) or %sysfunc(exist(&next_table, view)));
            put "_FLW_ACTION_TABLE_|&next_lib|" next_table_name +(-1) "|&table_exists";
        %end;
        dtStartStr = put(datetime(), E8601DZ.);
        put "_FLW_ACTION_END_|" dtStartStr +(-1) "|&nodes";
    run;
%mend _flw_action_end;
/* endregion */

/*===========================================================================*
* Node name:        Import File
* Node ID:          id-1750922108372-988
*
* Input Files:
*   /export/viya/homes/geoffrey.brands@student.torrens.edu.au/casuser/lendingclub51.csv
*
* Output Tables:
*   WORK._flw1750922108372988_0_0_1
*
* Step name:        Import
* Step path:        /dataFlows/steps/d38ccdec-66bc-43d0-84f0-faf8d-legacy
* Step description: Import step; used to import Delimited, Fixed-Width and Microsoft Excel files into SAS
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1750922108372-988);
/* endregion */

%LET global_validvarname = %sysfunc(getoption(validvarname));
OPTIONS VALIDVARNAME=ANY;
FILENAME _flw_fr "/export/viya/homes/geoffrey.brands@student.torrens.edu.au/casuser/lendingclub51.csv" encoding="UTF-8";

/* Delete table WORK._flw1750922108372988_0_0_1 */
proc datasets library = WORK memtype = (data view) nolist nowarn;
   delete _flw1750922108372988_0_0_1;
quit;

data WORK._flw1750922108372988_0_0_1;
   
   attrib
   member_id length = 8 format = BEST12. informat = BEST32. label = "member_id"
   interest_rate length = $5 format = $5. informat = $5. label = "interest_rate"
   emp_length length = $9 format = $9. informat = $9. label = "emp_length"
   verification_status length = $15 format = $15. informat = $15. label = "verification_status"
   issue_date length = 8 format = MMDDYY10. informat = MMDDYY10. label = "issue_date"
   loan_status length = $18 format = $18. informat = $18. label = "loan_status"
   purpose length = $18 format = $18. informat = $18. label = "purpose"
   total_pymnt length = 8 format = BEST12. informat = BEST32. label = "total_pymnt"
   recoveries length = 8 format = BEST12. informat = BEST32. label = "recoveries";
   
   infile _flw_fr
   lrecl = 32767
   encoding ="UTF-8"
   delimiter = ','
   firstobs = 2
   dsd
   missover;
   
   input
   member_id
   interest_rate
   emp_length
   verification_status
   issue_date
   loan_status
   purpose
   total_pymnt
   recoveries;
RUN;

FILENAME _flw_fr CLEAR;
OPTIONS VALIDVARNAME=&global_validvarname;

/* region: Generated step cleanup for Import File */
%_flw_action_end(id-1750922108372-988, WORK._flw1750922108372988_0_0_1, WORK, "_flw1750922108372988_0_0_1");
/* endregion */

/*===========================================================================*
* Node name:        Calculate Columns
* Node ID:          id-1750922933119-1841
*
* Input Tables:
*   WORK._flw1750922108372988_0_0_1
*
* Output Tables:
*   WORK._flw17509229331191841_0_0_2
*
* Step name:        Calculate Columns
* Step path:        /dataFlows/steps/32925769-6fac-4ce6-b2d9-7278526fccfd
* Step description: Calculate columns to modify existing or add new columns to a table
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1750922933119-1841);
/* endregion */


/* Delete table WORK._flw17509229331191841_0_0_2 */
proc datasets library = WORK memtype = (data view) nolist nowarn;
   delete _flw17509229331191841_0_0_2;
quit;

data WORK._flw17509229331191841_0_0_2;
   attrib

      interest_rate_clean
         length = 8
         label = ""
   ;


   set WORK._flw1750922108372988_0_0_1;
   interest_rate=kcompress(interest_rate,"""%"","" """);
   interest_rate_clean=input(interest_rate,BEST8.2);
run;

/* region: Generated step cleanup for Calculate Columns */
%_flw_action_end(id-1750922933119-1841, WORK._flw17509229331191841_0_0_2, WORK, "_flw17509229331191841_0_0_2");
/* endregion */

/*===========================================================================*
* Node name:        Filter Rows
* Node ID:          id-1750922947354-2034
*
* Input Tables:
*   WORK._flw17509229331191841_0_0_2
*
* Output Tables:
*   WORK._flw17509229473542034_0_0_3
*
* Step name:        Filter Rows
* Step path:        /dataFlows/steps/29351cc4-ab8e-40ed-804b-109f0b5a9b93
* Step description: Filter rows
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1750922947354-2034);
/* endregion */

/* Delete table WORK._flw17509229473542034_0_0_3 */
proc datasets library = WORK memtype = (data view) nolist nowarn;
   delete _flw17509229473542034_0_0_3;
quit;

data WORK._flw17509229473542034_0_0_3;
   set WORK._flw17509229331191841_0_0_2;
   where loan_status not is missing AND 
      purpose not is missing;
run;


/* region: Generated step cleanup for Filter Rows */
%_flw_action_end(id-1750922947354-2034, WORK._flw17509229473542034_0_0_3, WORK, "_flw17509229473542034_0_0_3");
/* endregion */

/*===========================================================================*
* Node name:        Manage Columns
* Node ID:          id-1751182455836-32453
*
* Input Tables:
*   WORK._flw17509229473542034_0_0_3
*
* Output Tables:
*   WORK.Final
*
* Step name:        Manage Columns
* Step path:        /dataFlows/steps/c1b50be2-5bb9-4216-ab9c-1105e16632ef
* Step description: Manage columns in a table.
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1751182455836-32453);
/* endregion */

/* Delete table WORK.Final */
proc datasets library = WORK memtype = (data view) nolist nowarn;
   delete Final;
quit;

/* _flw_: set DBIDIRECTEXEC */
%global _flw_dbidirectexec;
%let _flw_dbidirectexec = %sysfunc(getoption(dbidirectexec));
options dbidirectexec;

/* Create table: WORK.Final */
data _null_;
   put 'NOTE: Data Flows: Creating table WORK.Final...';
run;

proc sql;
   create table WORK.Final as
      select
         member_id,
         interest_rate_clean,
         emp_length,
         verification_status,
         issue_date,
         loan_status,
         purpose,
         total_pymnt,
         recoveries
      from WORK._flw17509229473542034_0_0_3;
quit;
run;

/* _flw_: reset DBIDIRECTEXEC */
options &_flw_dbidirectexec.;
%symdel _flw_dbidirectexec / nowarn;


/* region: Generated step cleanup for Manage Columns */
%_flw_action_end(id-1751182455836-32453, WORK.Final, WORK, "Final");
/* endregion */

/*===========================================================================*
* Node name:        Print Sample (final)
* Node ID:          id-1750922975247-2157
*
* Input Tables:
*   WORK.Final
*
* Step name:        Print Sample (final)
* Step path:        /dataFlows/steps/8b9b0227-89fe-49f0-9c79-2847217c6adb
* Step description: 
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1750922975247-2157);
/* endregion */

/* region: Generated macro initialization */

/* Define utility macros - BEGIN */

/* Macro to get a list of column names */
%macro _flw_get_column_list(_flw_prefix = %nrstr(), _delim=%str( ));
   %do _flw_index=1 %to %unquote(&&&_flw_prefix._count);%unquote(&&&_flw_prefix._&_flw_index._name)%if &_flw_index.<%unquote(&&&_flw_prefix._count)%then&_delim.; %end;
%mend;

/* Macro to delete macro variables with names passed in */
%macro _flw_del_macro_vars(_flw_macro_vars_to_delete,_flw_no_warn=Y);
   %if "&_flw_no_warn"="Y" %then %symdel &_flw_macro_vars_to_delete/NOWARN;
   %else %symdel &_flw_macro_vars_to_delete;
%mend;

/* Macro to delete a list of macros with names passed in */
%macro _flw_del_macros(_flw_macro_names,_flw_no_warn=Y);
   %let num=1;
   %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %do %while (&_flw_local_macros_to_delete ne );
      %if "&_flw_no_warn"="Y" %then %sysmacdelete &_flw_local_macros_to_delete/NOWARN;
      %else %sysmacdelete &_flw_local_macros_to_delete;
      %let num=%eval(&num+1);
      %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %end;
%mend;

/* Define utility macros - END */

/* Macro variables derived from user input to this step - BEGIN */

/* Macro variable(s) for UI control with ID of Table */
%let Table=WORK.Final;
%let Table_engine=V9;
%let Table_label=;
%let Table_lib=WORK;
%let Table_name=Final;
%let Table_name_base=Final;
%let Table_type=;

/* Macro variable(s) for UI control with ID of numRows */
%let numRows=20;

/* Macro variable(s) for UI control with ID of rsMethod */
%let rsMethod=SRS;

/* Macro variable(s) for UI control with ID of selection */
%let selection=FIRST;

/* Macro variable(s) for UI control with ID of varlist */
%let varlist=;
%let varlist_count=0;

/* Macro variables derived from user input to this step - END */

/* endregion */
/* SAS code provided in template section of Custom Step - BEGIN */
/* Selection options are FIRST (first rows) or RANDOM (random sample) */

/* GET TOTAL ROW COUNT FROM TABLE */
	
	proc sql noprint;
	    select count(*) format=comma15. into :N from &table;
	quit;

/* SELECT FIRST &numRows ROWS */
%if &selection=FIRST %then %do;
	title1 color="#545B66" "Sample from &table";
	title2 height=3 "First &numRows of &N Rows";
	data sample;
	    set &table(obs=&numRows keep=&varlist);
	run;
%end;

/* SELECT RANDOM SAMPLE OF &numRows ROWS */

%else %do;
	title1 color="#545B66" "Sample from &table";
	title2 height=3 "Random Sample &numRows of &N Rows";
	
	proc surveyselect data=&table(keep=&varlist) 
	                  method=&rsMethod n=&numRows
	                  out=sample noprint;
	run;  
%end; 

/* PRINT SAMPLE */

	footnote height=3 "Created %sysfunc(today(),nldatew.) at %sysfunc(time(), nltime.)";
	proc print data=sample noobs;
	run;
	title;
	footnote;
/* SAS templated code goes here */
/* SAS code provided in template section of Custom Step - END */

/* region: Generated macro cleanup */

/* Cleanup macros and macro variables - BEGIN */
/* Delete macro variables created in this step */

%_flw_del_macro_vars( Table Table_engine Table_label Table_lib Table_name Table_name_base
                  Table_type );
%_flw_del_macro_vars( numRows );
%_flw_del_macro_vars( rsMethod );
%_flw_del_macro_vars( selection );
%_flw_del_macro_vars( varlist varlist_count );
/* Delete macros defined in this step */
%_flw_del_macros(_flw_get_column_list _flw_del_macro_vars);

/* Cleanup macros and macro variables - END */

%sysmacdelete _flw_del_macros;

/* endregion */


/* region: Generated step cleanup for Print Sample (final) */
%_flw_action_end(id-1750922975247-2157, , , );
/* endregion */

/*===========================================================================*
* Node name:        Summary Statistics
* Node ID:          id-1750923024531-2944
*
* Input Tables:
*   WORK.Final
*
* Output Tables:
*   WORK._flw17509230245312944_0_0_4
*
* Step name:        Summary Statistics
* Step path:        /dataFlows/steps/a4568a65-a688-452d-a364-05b6c072d493
* Step description: The Summary Statistics step provides descriptive statistics for variables across all observations and within groups of observations. It also generates histograms and box plots.
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1750923024531-2944);
/* endregion */

/* region: Generated macro initialization */

/* Define utility macros - BEGIN */

/* Macro to get a list of column names */
%macro _flw_get_column_list(_flw_prefix = %nrstr(), _delim=%str( ));
   %do _flw_index=1 %to %unquote(&&&_flw_prefix._count);%unquote(&&&_flw_prefix._&_flw_index._name)%if &_flw_index.<%unquote(&&&_flw_prefix._count)%then&_delim.; %end;
%mend;

/* Macro to delete macro variables with names passed in */
%macro _flw_del_macro_vars(_flw_macro_vars_to_delete,_flw_no_warn=Y);
   %if "&_flw_no_warn"="Y" %then %symdel &_flw_macro_vars_to_delete/NOWARN;
   %else %symdel &_flw_macro_vars_to_delete;
%mend;

/* Macro to delete a list of macros with names passed in */
%macro _flw_del_macros(_flw_macro_names,_flw_no_warn=Y);
   %let num=1;
   %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %do %while (&_flw_local_macros_to_delete ne );
      %if "&_flw_no_warn"="Y" %then %sysmacdelete &_flw_local_macros_to_delete/NOWARN;
      %else %sysmacdelete &_flw_local_macros_to_delete;
      %let num=%eval(&num+1);
      %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %end;
%mend;

/* Define utility macros - END */

/* Macro variables derived from user input to this step - BEGIN */

/* Macro variable(s) for UI control with ID of P1 */
%let P1=0;

/* Macro variable(s) for UI control with ID of P10 */
%let P10=0;

/* Macro variable(s) for UI control with ID of P5 */
%let P5=0;

/* Macro variable(s) for UI control with ID of P90 */
%let P90=0;

/* Macro variable(s) for UI control with ID of P95 */
%let P95=0;

/* Macro variable(s) for UI control with ID of P99 */
%let P99=0;

/* Macro variable(s) for UI control with ID of Q1 */
%let Q1=0;

/* Macro variable(s) for UI control with ID of Q3 */
%let Q3=0;

/* Macro variable(s) for UI control with ID of analysisVariables */
%let analysisVariables=total_pymnt recoveries member_id interest_rate_clean issue_date;
%let analysisVariables_count=5;

/* Macro variables for column <total_pymnt> */
%let analysisVariables_1_format=BEST12.;
%let analysisVariables_1_informat=BEST32.;
%let analysisVariables_1_label=;
%let analysisVariables_1_name=total_pymnt;
%let analysisVariables_1_name_base=total_pymnt;
%let analysisVariables_1_rawlength=8;
%let analysisVariables_1_type=Numeric;

/* Macro variables for column <recoveries> */
%let analysisVariables_2_format=BEST12.;
%let analysisVariables_2_informat=BEST32.;
%let analysisVariables_2_label=;
%let analysisVariables_2_name=recoveries;
%let analysisVariables_2_name_base=recoveries;
%let analysisVariables_2_rawlength=8;
%let analysisVariables_2_type=Numeric;

/* Macro variables for column <member_id> */
%let analysisVariables_3_format=BEST12.;
%let analysisVariables_3_informat=BEST32.;
%let analysisVariables_3_label=;
%let analysisVariables_3_name=member_id;
%let analysisVariables_3_name_base=member_id;
%let analysisVariables_3_rawlength=8;
%let analysisVariables_3_type=Numeric;

/* Macro variables for column <interest_rate_clean> */
%let analysisVariables_4_format=;
%let analysisVariables_4_informat=;
%let analysisVariables_4_label=;
%let analysisVariables_4_name=interest_rate_clean;
%let analysisVariables_4_name_base=interest_rate_clean;
%let analysisVariables_4_rawlength=8;
%let analysisVariables_4_type=Numeric;

/* Macro variables for column <issue_date> */
%let analysisVariables_5_format=MMDDYY10.;
%let analysisVariables_5_informat=MMDDYY10.;
%let analysisVariables_5_label=;
%let analysisVariables_5_name=issue_date;
%let analysisVariables_5_name_base=issue_date;
%let analysisVariables_5_rawlength=8;
%let analysisVariables_5_type=Numeric;

/* Macro variable(s) for UI control with ID of boxPlot */
%let boxPlot=1;

/* Macro variable(s) for UI control with ID of boxPlotGroupInset */
%let boxPlotGroupInset=0;

/* Macro variable(s) for UI control with ID of boxPlotGroupInsetPosition */
%let boxPlotGroupInsetPosition=boxPlotGroupInsetPositionTop;

/* Macro variable(s) for UI control with ID of boxPlotInset */
%let boxPlotInset=0;

/* Macro variable(s) for UI control with ID of boxPlotInsetPosition */
%let boxPlotInsetPosition=boxPlotInsetPositionNW;

/* Macro variable(s) for UI control with ID of byVariables */
%let byVariables=;
%let byVariables_count=0;

/* Macro variable(s) for UI control with ID of classVariables */
%let classVariables=;
%let classVariables_count=0;

/* Macro variable(s) for UI control with ID of coef */
%let coef=0;

/* Macro variable(s) for UI control with ID of conf */
%let conf=0;

/* Macro variable(s) for UI control with ID of confLevel */
%let confLevel=cf95;

/* Macro variable(s) for UI control with ID of confValue */
%let confValue=95;

/* Macro variable(s) for UI control with ID of copyValue */
%let copyValue=max;

/* Macro variable(s) for UI control with ID of copyVariables */
%let copyVariables=;
%let copyVariables_count=0;

/* Macro variable(s) for UI control with ID of css */
%let css=0;

/* Macro variable(s) for UI control with ID of customAnalysisTitles */
%let customAnalysisTitles=;

/* Macro variable(s) for UI control with ID of customBoxPlotTitles */
%let customBoxPlotTitles=;

/* Macro variable(s) for UI control with ID of customFootnotes */
%let customFootnotes=;

/* Macro variable(s) for UI control with ID of customHistTitles */
%let customHistTitles=;

/* Macro variable(s) for UI control with ID of defaultAnalysisTitlesText */
%let defaultAnalysisTitlesText=%nrquote(Summary Statistics
Results);
%let defaultAnalysisTitlesText_count=2;
%let defaultAnalysisTitlesText_1=%nrquote(Summary Statistics);
%let defaultAnalysisTitlesText_2=Results;

/* Macro variable(s) for UI control with ID of defaultBoxPlotTitlesText */
%let defaultBoxPlotTitlesText=%nrquote(Summary Statistics
Box Plot);
%let defaultBoxPlotTitlesText_count=2;
%let defaultBoxPlotTitlesText_1=%nrquote(Summary Statistics);
%let defaultBoxPlotTitlesText_2=%nrquote(Box Plot);

/* Macro variable(s) for UI control with ID of defaultFootnotesText */
%let defaultFootnotesText=%nrquote(Generated by SAS on %%TRIM%(%%QSYSFUNC%(DATE%(%), NLDATE20.%)%) at %%TRIM%(%%QSYSFUNC%(TIME%(%), NLTIMAP25.%)%));

/* Macro variable(s) for UI control with ID of defaultHistTitlesText */
%let defaultHistTitlesText=%nrquote(Summary Statistics
Histogram);
%let defaultHistTitlesText_count=2;
%let defaultHistTitlesText_1=%nrquote(Summary Statistics);
%let defaultHistTitlesText_2=Histogram;

/* Macro variable(s) for UI control with ID of divisor */
%let divisor=DDOF;

/* Macro variable(s) for UI control with ID of divisorWgt */
%let divisorWgt=DDOFWGT;

/* Macro variable(s) for UI control with ID of errorLabel_analysisVariables */
%let errorLabel_analysisVariables=%nrquote(Analysis variables:);

/* Macro variable(s) for UI control with ID of errorLabel_confidenceValue */
%let errorLabel_confidenceValue=%nrquote(Custom confidence level %(%%%):);

/* Macro variable(s) for UI control with ID of errorLabel_inputData */
%let errorLabel_inputData=%nrquote(Input data:);

/* Macro variable(s) for UI control with ID of errorLabel_outputData */
%let errorLabel_outputData=%nrquote(Output data:);

/* Macro variable(s) for UI control with ID of errorLabel_replaceOutputTable */
%let errorLabel_replaceOutputTable=%nrquote(Replace existing output table);

/* Macro variable(s) for UI control with ID of errorLabel_stepName */
%let errorLabel_stepName=%nrquote(Summary Statistics);

/* Macro variable(s) for UI control with ID of error_atLeastOneVarReqd */
%let error_atLeastOneVarReqd=%nrquote({0} requires the selection of at least one variable.);

/* Macro variable(s) for UI control with ID of error_badLoopByValue */
%let error_badLoopByValue=%nrquote(Expecting an integer for the %'by%' value of a loop in the Ways expression.);

/* Macro variable(s) for UI control with ID of error_badLoopEndValue */
%let error_badLoopEndValue=%nrquote(Expecting an integer for the %'end%' value for a loop in the Ways expression.);

/* Macro variable(s) for UI control with ID of error_badLoopStartValue */
%let error_badLoopStartValue=%nrquote(The value of the Ways loop start value %({0}%) is greater than the end value %({1}%).);

/* Macro variable(s) for UI control with ID of error_badRangeEndValue */
%let error_badRangeEndValue=%nrquote(Expecting an integer for the %'end%' value for a range in the Ways expression.);

/* Macro variable(s) for UI control with ID of error_badRangeStartValue */
%let error_badRangeStartValue=%nrquote(The value of the Ways range start value %({0}%) is greater than the end value %({1}%).);

/* Macro variable(s) for UI control with ID of error_badTableName */
%let error_badTableName=%nrquote(The {0} table name %"{1}%" does not follow SAS naming conventions.);

/* Macro variable(s) for UI control with ID of error_cannotReplaceTable */
%let error_cannotReplaceTable=%nrquote(The table selected for {0} %(%"{1}%"%) already exists, and the {2} option is not selected.);

/* Macro variable(s) for UI control with ID of error_errorsInSpecificWays */
%let error_errorsInSpecificWays=%nrquote(The %'Specific ways%' expression contains the following error:);

/* Macro variable(s) for UI control with ID of error_errorsInStep */
%let error_errorsInStep=%nrquote(The {0} step contained the following {1} errors and could not be run:);

/* Macro variable(s) for UI control with ID of error_expectedAnInteger */
%let error_expectedAnInteger=%nrquote(An invalid character was found in the Ways expression where an integer was expected.);

/* Macro variable(s) for UI control with ID of error_indivValsNotAllowed */
%let error_indivValsNotAllowed=%nrquote(Individual numeric values are not permitted in the Ways expression.);

/* Macro variable(s) for UI control with ID of error_internalGetWaysError */
%let error_internalGetWaysError=%nrquote(The following internal error occurred while processing the Ways expression -);

/* Macro variable(s) for UI control with ID of error_loopEndValueTooBig */
%let error_loopEndValueTooBig=%nrquote(The value of the Ways loop end value %({0}%) exceeds the total number of classification columns %({1}%).);

/* Macro variable(s) for UI control with ID of error_loopsNotAllowed */
%let error_loopsNotAllowed=%nrquote(Loops are not permitted in the Ways expression.);

/* Macro variable(s) for UI control with ID of error_midpointsBinsInvalid */
%let error_midpointsBinsInvalid=%nrquote(The %'Bins%' value %({0}%) for the histogram plot midpoints must be an integer value which is greater than or equal to 2.);

/* Macro variable(s) for UI control with ID of error_midpointsStartGTEnd */
%let error_midpointsStartGTEnd=%nrquote(The %'Start%' value %({0}%) for the histogram plot midpoints must not be greater than the %'End%' value %({1}%).);

/* Macro variable(s) for UI control with ID of error_midpointsStepLTZero */
%let error_midpointsStepLTZero=%nrquote(The %'Step%' value %({0}%) for the histogram plot midpoints must not less than 0.);

/* Macro variable(s) for UI control with ID of error_multipleItemsNotAllowed */
%let error_multipleItemsNotAllowed=%nrquote(Multiple items are not permitted in the Ways expression.);

/* Macro variable(s) for UI control with ID of error_numInRangeGTLT */
%let error_numInRangeGTLT=%nrquote({0} requires a number greater than {1} and less than {2}.);

/* Macro variable(s) for UI control with ID of error_rangeEndValueTooBig */
%let error_rangeEndValueTooBig=%nrquote(The value of the Ways range end value %({0}%) exceeds the total number of classification columns %({1}%).);

/* Macro variable(s) for UI control with ID of error_rangesNotAllowed */
%let error_rangesNotAllowed=%nrquote(Ranges are not permitted in the Ways expression.);

/* Macro variable(s) for UI control with ID of error_specificWaysIsEmpty */
%let error_specificWaysIsEmpty=%nrquote(There have been no %'Specific ways%' specified.);

/* Macro variable(s) for UI control with ID of error_statOrPlotNeeded */
%let error_statOrPlotNeeded=%nrquote(Select at least one statistic or one plot.);

/* Macro variable(s) for UI control with ID of error_statOrPlotOrTableRequired */
%let error_statOrPlotOrTableRequired=%nrquote(At least one of the options %'Show statistics%', %'Histogram%', %'Box plot%', or %'Create output data set%' must be selected.);

/* Macro variable(s) for UI control with ID of error_tableInfoIncomplete */
%let error_tableInfoIncomplete=%nrquote(The {0} table information is incomplete. Either the %'Library%' or %'Table name%' is empty.);

/* Macro variable(s) for UI control with ID of error_tableSelectedTwice */
%let error_tableSelectedTwice=%nrquote(The table selected for {0} %(%"{1}%"%) cannot be the same as the {2} table.);

/* Macro variable(s) for UI control with ID of error_tooManyClassVars */
%let error_tooManyClassVars=%nrquote(The total number of classification variables %({1}%) exceeds {0}, which is the maximum the step can can process.);

/* Macro variable(s) for UI control with ID of error_valueTooBig */
%let error_valueTooBig=%nrquote(The value of the Ways number %({0}%) exceeds the total number of classification columns %({1}%).);

/* Macro variable(s) for UI control with ID of freqVariable */
%let freqVariable=;
%let freqVariable_count=0;

/* Macro variable(s) for UI control with ID of hist */
%let hist=0;

/* Macro variable(s) for UI control with ID of histogramInset */
%let histogramInset=0;

/* Macro variable(s) for UI control with ID of histogramInsetPosition */
%let histogramInsetPosition=histogramInsetPositionNW;

/* Macro variable(s) for UI control with ID of inputData */
%let inputData=WORK.Final;
%let inputData_engine=V9;
%let inputData_label=;
%let inputData_lib=WORK;
%let inputData_name=Final;
%let inputData_name_base=Final;
%let inputData_type=;

/* Macro variable(s) for UI control with ID of kernelDensityPlot */
%let kernelDensityPlot=0;

/* Macro variable(s) for UI control with ID of kurtosis */
%let kurtosis=0;

/* Macro variable(s) for UI control with ID of max */
%let max=1;

/* Macro variable(s) for UI control with ID of maxDecimal */
%let maxDecimal=bestFit;

/* Macro variable(s) for UI control with ID of mean */
%let mean=1;

/* Macro variable(s) for UI control with ID of median */
%let median=0;

/* Macro variable(s) for UI control with ID of midpoints */
%let midpoints=0;

/* Macro variable(s) for UI control with ID of midpointsBins */
%let midpointsBins=5;

/* Macro variable(s) for UI control with ID of midpointsEnd */
%let midpointsEnd=10;

/* Macro variable(s) for UI control with ID of midpointsStart */
%let midpointsStart=1;

/* Macro variable(s) for UI control with ID of midpointsStep */
%let midpointsStep=2;

/* Macro variable(s) for UI control with ID of midpointsType */
%let midpointsType=specify;

/* Macro variable(s) for UI control with ID of min */
%let min=1;

/* Macro variable(s) for UI control with ID of missing */
%let missing=1;

/* Macro variable(s) for UI control with ID of mode */
%let mode=0;

/* Macro variable(s) for UI control with ID of noClassMidpointsType */
%let noClassMidpointsType=specify;

/* Macro variable(s) for UI control with ID of nobs */
%let nobs=1;

/* Macro variable(s) for UI control with ID of normalDensityPlot */
%let normalDensityPlot=0;

/* Macro variable(s) for UI control with ID of outputDS */
%let outputDS=0;

/* Macro variable(s) for UI control with ID of outputTable */
%let outputTable=WORK._flw17509230245312944_0_0_4;
%let outputTable_engine=BASE;
%let outputTable_label=;
%let outputTable_lib=WORK;
%let outputTable_name=_flw17509230245312944_0_0_4;
%let outputTable_name_base=_flw17509230245312944_0_0_4;
%let outputTable_type=;

/* Macro variable(s) for UI control with ID of qrange */
%let qrange=0;

/* Macro variable(s) for UI control with ID of quantile */
%let quantile=QMOS;

/* Macro variable(s) for UI control with ID of quantileWgt */
%let quantileWgt=QMOSWGT;

/* Macro variable(s) for UI control with ID of range */
%let range=0;

/* Macro variable(s) for UI control with ID of replaceOutputTable */
%let replaceOutputTable=1;

/* Macro variable(s) for UI control with ID of showLabels */
%let showLabels=1;

/* Macro variable(s) for UI control with ID of showStatistics */
%let showStatistics=1;

/* Macro variable(s) for UI control with ID of skewness */
%let skewness=0;

/* Macro variable(s) for UI control with ID of specifyWays */
%let specifyWays=%nrquote(0, 1);

/* Macro variable(s) for UI control with ID of std */
%let std=1;

/* Macro variable(s) for UI control with ID of stdErr */
%let stdErr=0;

/* Macro variable(s) for UI control with ID of sum */
%let sum=1;

/* Macro variable(s) for UI control with ID of sumWeights */
%let sumWeights=0;

/* Macro variable(s) for UI control with ID of tstat */
%let tstat=0;

/* Macro variable(s) for UI control with ID of useDefaultAnalysisTitles */
%let useDefaultAnalysisTitles=0;

/* Macro variable(s) for UI control with ID of useDefaultBoxPlotTitles */
%let useDefaultBoxPlotTitles=0;

/* Macro variable(s) for UI control with ID of useDefaultFootnotes */
%let useDefaultFootnotes=0;

/* Macro variable(s) for UI control with ID of useDefaultHistTitles */
%let useDefaultHistTitles=0;

/* Macro variable(s) for UI control with ID of uss */
%let uss=0;

/* Macro variable(s) for UI control with ID of utilityTableErrorsNote */
%let utilityTableErrorsNote=%nrquote(There were {0} runtime errors which may be viewed in the log.);

/* Macro variable(s) for UI control with ID of utilityTableMainNote */
%let utilityTableMainNote=%nrquote(This is a utility table created by the Summary Statistics step that may be ignored.);

/* Macro variable(s) for UI control with ID of variance */
%let variance=0;

/* Macro variable(s) for UI control with ID of ways */
%let ways=nway;

/* Macro variable(s) for UI control with ID of weightVariable */
%let weightVariable=;
%let weightVariable_count=0;

/* Macro variables derived from user input to this step - END */

/* endregion */
/* SAS code provided in template section of Custom Step - BEGIN */
/* ************************************************************************* */
/* Summary Statistics provides equivalent functionality as the CTM Summary
   Statistics task.

   Release cadence: 2024.03
*/

/* ************************************************************************* */
/* Inserts values into a localized  message string at the locations
   indicated by tokens of the form '{0}' through '{9}'.
*/
%macro __tranmsg(msg  /* message text with keys {0} - {9} as needed */, value0 /* value for {0} */,
                 value1 /* value for {1} */, value2 /* value for {2} */, value3 /* value for {3} */,
                 value4 /* value for {4} */, value5 /* value for {5} */, value6 /* value for {6} */,
                 value7 /* value for {7} */, value8 /* value for {8} */, value9 /* value for {9} */);
    %local _retVal _i;
    %let _retVal = %superq(msg);
    %let _i = 0;
    %do %while (&_i <= 9 AND %index(%superq(msg), {&_i}) NE 0);
        %let _retval = %qsysfunc(tranwrd(&_retval, {&_i}, %superq(value&_i)));
        %let _i = %eval(&_i + 1);
    %end;
    %superq(_retVal)
%mend __tranmsg;

/* ************************************************************************* */
/* Wraps the supplied label value in single quotes after attempting to
   remove any trailing colon as well as any text enclosed within
   parentheses at the end of the string.
*/
%macro __formatLabel(label);
    %local _reversed _lastChar _firstParen _retVal;
    %let _retVal = ;
    %if %length(&label) NE 0 %then %do;
        %let _reversed = %qtrim(%qsysfunc(reverse(%qtrim(&label))));
        /* Look for a trailing colon and remove it if one is found. */
        %let _lastChar = %qsubstr(&_reversed, 1, 1);
        %if &_lastChar = %str(:) %then %do;
            %let _reversed = %qtrim(%qsubstr(&_reversed, 2));
        %end;
        /* Now check to see if there is text within parentheses at
           the end of the label's string. If found, remove the
           parentheses and all text enclosed. */
        %let _retVal = %qtrim(%qsysfunc(reverse(&_reversed)));
        %let _lastChar = %qsubstr(&_retVal, %length(&_retVal), 1);
        %let _firstParen = %index(&_retVal, %str(%());
        %if &_lastChar = %str(%)) AND &_firstParen > 0 %then %do;
            %let _retVal = %qtrim(%qsubstr(&_retVal, 1, &_firstParen - 1));
        %end;
    %end;
    %str(%'%superq(_retVal)%')
%mend __formatLabel;

/* ************************************************************************* */
/* The locally defined __code() macro writes the generated SAS code inline
   for execution. If an externally defined macro of that name exists, then
   we don't need to create the local version.
*/
%let __locallyDefinedCodeMacro = 0;
%if %sysmacexist(__code) = 0 %then %do;
    %let __locallyDefinedCodeMacro = 1;
    %macro __code(sasCode);
        %unquote(&sasCode);
    %mend;
%end;

/* ************************************************************************* */
/* The locally defined __processErrors() macro writes all error messages to
   the log and then aborts the processing. If an externally defined macro
   of that name exists, then we don't need to create the local version.
   This version will wrap error messages over multiple log lines while
   styling the subsequent lines as part of the first error line.
*/
%let __locallyDefinedProcErrsMacro = 0;
%if %sysmacexist(__processErrors) = 0 %then %do;
    %let __locallyDefinedProcErrsMacro = 1;
    %macro __processErrors(errorSummaryMsg);
        /* Save the current CMPLIB option setting. */
        %let _option_cmplib=%sysfunc(getoption(cmplib, keyword));
        /* Use our function library. */
        options cmplib=work._functions;

        /* Use a data step to process the error messages because it's
           easier to handle new lines in data step code that it is
           within the macro environment. */
        data _null_;
            length errMsg $ 4096;

            NL = byte(13);
            NLTOKEN = "{\n}";

            errMsg = "ERROR: " || tranwrd(%sysfunc(quote(&errorSummaryMsg)), "{0}", "&__errorMsg_count");
            link putErrorToLog;

            errMsg_count = symgetn("__errorMsg_count");
            do errMsg_index = 1 to errMsg_count;
                errMsg = symget("__errorMsg_" || trim(left(put(errMsg_index, 4.))));

                link putErrorToLog;
            end;
          stop;

        putErrorToLog:
            /* Prepare the error message for printing to the log and
               convert all new line tokens to actual new lines. */
            errMsg = tranwrd(prepareErrorForLog(errMsg), NLTOKEN, NL);
            /* Determine how many lines we have to write to the log. */
            lineSeps = count(errMsg, NL);
            /* Write each line to the log. */
            do lineNo = 1 to lineSeps + 1;
                line = scan(errMsg, lineNo, NL);
                put line;
            end;
            return;
        run;

        /* Tidy up our previously defined function library. */
        proc fcmp outlib=work._functions.func;
            deletefunc prepareErrorForLog;
            deletefunc skipSpaces;
            deletefunc getWays;
            deletesubr getRuler;
        run;

        /* Restore the CMPLIB option back to what it was previously. */
        options &_option_cmplib;

        proc datasets library=WORK nolist nowarn memtype = (data view);
            delete _functions;
        quit;
        /* Create an empty table to workaround the server including tables
           that have been deleted in the list of output tables. */
        data work._functions;
            note = symget("utilityTableMainNote");
            output;
            note = tranwrd(symget("utilityTableErrorsNote"), "{0}", symget("__errorMsg_count"));
            output;
          stop;
        run;

        /* Tidy up the error macro variables. */
        %local _errorMsg_index;
        %do _errorMsg_index = 1 %to &__errorMsg_count;
            %symdel __errorMsg_&_errorMsg_index;
        %end;
        %symdel __errorMsg_count;

        %abort;
    %mend;
%end;

/* ************************************************************************* */
/* Performs the validation checks. And adds the supplied message to the
   errors 'array' if the test value is true.
*/
%macro __runtimeValidation(test, msg);
    %if &test %then %do;
        %let __errorMsg_count = %eval(&__errorMsg_count + 1);
        %global __errorMsg_&__errorMsg_count;
        %let __errorMsg_&__errorMsg_count = %str(ERROR: &msg);
    %end;
%mend;

/* ************************************************************************* */
/* runStep() generates the code appropriate for the Summary Statistics
   step to generated the output as per the user's selections.
*/
%macro runStep();
    /* Globally defined so that the __processErrors macro can get
       access to it. */
    %global
        __errorMsg_count
    ;
    /* Locally scoped macro variables so that we don't interfere with
       similarly named variables defined outside of this macro. */
    %local
        _errorMsg_index
        _outputTableError
        _mprintOption
        _alpha
        _analysisVar
        _analysisVarIndex
        _byVarIndex
        _classVar
        _classVarIndex
        _lastByVar
        _levelIndex
        _lft
        _numLevel
        _option_cmplib
        _percentilesSelected
        _rgt
        _statsSelected
        _tempCode
        _optionCode
        _upcaseProp
        _useDivisor
        _useDivisorWgt
        _useQuantiles
        _useQuantilesWgt
        _wayValues

        _hasWeightVar
        _hasClassVars
        _hasByVars

        _rootTitleName
        _titleIdx
        _maxLoops
    ;

    /* ----------------------------------------- */
    /* -- Initialization of Utility Variables -- */

    /* Have any percentile statistics been selected? */
    %let _percentilesSelected = 0;
    %if &P1 = 1 OR &P5 = 1 OR &P10 = 1 OR &Q1 = 1 OR &median = 1 OR
        &Q3 = 1 OR &P90 = 1 OR &P95 = 1 OR &P99 = 1 OR &qrange = 1 %then %do;
        %let _percentilesSelected = 1;
    %end;

    /* Has a weight variable been selected? */
    %let _hasWeightVar = 0;
    %if &weightVariable_count > 0 %then %do;
        %let _hasWeightVar = 1;
    %end;

    /* Have class variables been selected? */
    %let _hasClassVars = 0;
    %if &classVariables_count > 0 %then %do;
        %let _hasClassVars = 1;
    %end;

    /* Have by variables been selected? */
    %let _hasByVars = 0;
    %if &byVariables_count > 0 %then %do;
        %let _hasByVars = 1;
    %end;

    /* Have statistics of any type been selected? */
    %let _statsSelected = 0;
    %if &mean = 1 OR &std = 1 OR &min = 1 OR &max = 1 OR &nobs = 1 OR &missing = 1 OR
        &stdErr = 1 OR &variance = 1 OR (&_hasWeightVar = 0 AND &mode = 1) OR &range = 1 OR
        &sum = 1 OR (&_hasWeightVar = 1 AND &sumWeights = 1) OR &conf = 1 OR &coef = 1 OR
        &css = 1 OR &uss = 1 OR &tstat = 1 OR
        (&_hasWeightVar = 0 AND (&skewness = 1 OR &kurtosis = 1)) OR &_percentilesSelected = 1 %then %do;
        %let _statsSelected = 1;
    %end;

    %let _useDivisor = 0;
    %if &_hasWeightVar = 0 AND &_statsSelected = 1 %then %do;
        %let _useDivisor = 1;
    %end;

    %let _useDivisorWgt = 0;
    %if &_hasWeightVar > 0 AND &_statsSelected = 1 %then %do;
        %let _useDivisorWgt = 1;
    %end;

    %let _useQuantiles = 0;
    %if &_hasWeightVar = 0 AND &_percentilesSelected = 1 %then %do;
        %let _useQuantiles = 1;
    %end;

    %let _useQuantilesWgt = 0;
    %if &_hasWeightVar > 0 AND &_percentilesSelected = 1 %then %do;
        %let _useQuantilesWgt = 1;
    %end;

    /* ------------------------ */
    /* Define Utility Functions */

    /* Cut down on the code shown in the log by turning off MPRINT. */
    %let _mprintOption = %sysfunc(getoption(MPRINT));
    OPTIONS NOMPRINT;

    %if %sysfunc(exist(work._functions, DATA)) OR %sysfunc(exist(work._functions, VIEW)) %then %do;
        proc datasets lib=work nolist nowarn memtype = (data view);
            delete _functions;
        quit;
    %end;
    proc fcmp outlib=work._functions.func;
        /* The index of the next non-space character starting from startPos.
           0 is returned if there are no more non-space characters in the
           string or startPos has a value of 0 when called.
        */
        function skipSpaces(str $, startPos);
            strLen = length(str);
            if startPos= 0 OR startPos > strLen then do;
                return (0);
            end;
            /* Locate the next non-space character. */
            return (findc(str, " ", "k", startPos));
        endsub;

        /* Returns a ruler long enough for the supplied string and displays
           the string beneath it.
           If caretPos is non zero, then a caret is placed on the line below
           the line containing the string to highlight the character at that
           location.
           New line tokens ("{\n}") are placed between the lines in the
           returned string.
           Examples:
               getRuler("1, 3.5, 6", 0) will return the string:
                   "         10{\n}----+----|{\n}1, 3.5, 6"
               and when the "{\n}" values are replaced with \n characters and
               written to the SAS log it will look like this:

                            10
                   ----+----|
                   1, 3.5, 6

                getRuler("1, 3.5, 6", 5) will return the string:
                   "         10{\n}----+----|{\n}1, 3.5, 6{\n}    ^"
               and when the "{\n}" values are replaced with \n characters and
               written to the SAS log will look like this with a caret in the
               last line pointing to the 5th character in the string (3rd line):

                            10
                   ----+----|
                   1, 3.5, 6
                       ^
        */
        function getRuler(str $, caretPos) $ 402;
            LEN = length(str);
            NLTOKEN ="{\n}";
            TENTICKS = "----+----|";

            length ticks $ 200
                colNums $ 202
                caretString $ 8500;

            /* Generate the ruler numbers and ticks. */
            do i = 1 to LEN by 10;
                /* Determine how many characters are needed to display the
                   ruler number. */
                digits = floor(log10(i + 9)) + 1;
                substr(colNums, i + 9, digits) = trim(left(put((i + 9), 3.)));
                ticks = cats(ticks, TENTICKS);
            end;
            substr(colNums, 1, 5) = "Cols:";

            /* Put everything together. */
            if caretPos = 0 then do;
                return (
                    trim(colNums) || NLTOKEN ||
                    trim(ticks) || NLTOKEN ||
                    trim(str)
                );
            end;
            /* Add a caret to indicate the specific column. */
            if caretPos = 1 then do;
                caretString = "^";
            end;
            else do;
                caretString = repeat(" ", caretPos - 2) || "^";
            end;
            return (
                trim(colNums) || NLTOKEN ||
                trim(ticks) || NLTOKEN ||
                trim(str) || NLTOKEN ||
                trim(caretString)
            );
        endsub;

        /* Formats (but does not print) an ERROR message to the log with the
           message appearing as a multiple line error message if it is too
           long to fit on a single line (as determined by the SAS LINESIZE
           option). The message may contain new line tokens ("{\n}") and/or
           characters (\n) characters which will force a line to be split
           wherever the new line tokens/characters occur.
           The returned string will contain new line tokens ("{\n}");
        */
        function prepareErrorForLog(errMsg $) $ 4096;
            length
                line $ 512
                msg $ 4096
                newMsg $ 4096
            ;
            LS = input(getoption("LINESIZE"), best.);
            NL = byte(13);
            NLTOKEN = "{\n}";

            /* Convert all new line tokens ("{\n}") within the incoming
               message string to new line (\n) characters. */
                msg = tranwrd(errMsg, NLTOKEN, NL);

            /* We expect the message to have an "ERROR: " prefix. */
            if substr(msg, 1, 7) = "ERROR: " then do;
                msgLen = length(msg);

                prefixSize = 0;
                startPos = 1;
                /* Locate the first NL character. */
                nextCRPos = find(msg, NL);
                do while (startPos <= msgLen);
                    endPos = startPos + LS - 1 - prefixSize;
                    /* Check if we should be using the position of the
                       next NL as the end of the current line. */
                    if nextCRPos NE 0 AND nextCRPos < endPos then do;
                        endPos = nextCRPos;
                        nextCRPos = find(msg, NL, nextCRPos + 1);
                    end;
                    if endPos >= msgLen AND msgLen - startPos < LS - prefixSize then do;
                        /* The remaining text fits within a log line, so
                           this is the final line. */
                        line = substr(msg, startPos, msgLen - startPos + 1);
                        spacePos = msgLen + 1;
                    end;
                    else do;
                        if endPos - startPos + 1 < LS - prefixSize  then do;
                            /* The line will fit within the log line unaltered. */
                            line = "";
                            len = endPos - startPos + 1;
                            if len > 0 then do;
                                line = substr(msg, startPos, len);
                            end;
                            spacePos = endPos + 1;
                        end;
                        else do;
                            if substr(msg, endPos, 1) NE NL AND substr(msg, endPos + 1, 1) = " " then do;
                                /* The line was not terminated by a NL and the next
                                   character following the end position is a space
                                   then we can use the endPos as is.*/
                                line =  substr(msg, startPos, (endPos - startPos) + 1);
                                spacePos = endPos + 2;
                            end;
                            else do;
                                /* We need to find the last space to split the
                                    message at. If the space is found prior to the
                                    current start position, then we have to force a
                                    split of the current line. */
                                spacePos = findc(msg, " ", " ", -endPos);
                                if spacePos < ifn(startPos = 1, 8, startPos) then do;
                                    spacePos = endPos + 1;
                                end;
                                else do;
                                    spacePos + 1;
                                end;
                                if spacePos <= startPos then do;
                                    line = "";
                                end;
                                else do;
                                    line = substr(msg, startPos, spacePos - startPos);
                                end;
                            end;
                        end;
                    end;
                    /* For second and subsequent lines we need to add the error
                       continuation prefix to the line. */
                    line = ifc(startPos = 1, line, "ERROR- " || line);
                    /* Append the line to the new message string, placing a
                       new line token between the lines.
                       NOTE: The message could have been written to the log here
                       but there is an issue with the PUT statement in PROC FCMP
                       where the "ERROR-" prefix is treated as normal text. */
                    newMsg = ifc(prefixSize = 0, line, trim(newMsg) || NLTOKEN || line);

                    startPos = spacePos;
                    /* The length of the error continuation prefix to be added to
                       the second and subsequent lines. */
                    prefixSize = 7;
                end;
            end;
            else do;
                /* There is no ERROR prefix, so let's just put the message out. */
                newMsg = msg;
            end;
            return (trim(newMsg));
        endsub;

        /* Takes a Ways expression which specifies Ways values in the form of a series of
           individual integer values, ranges (start ... end) or loops
           (start to end [by step]) and returns the expanded list of values represented
           by the expression.
           Each Ways specification is checked to ensure that the values are not greater
           than the number of classification variables (specified in the numClassVars
           parameter).
           The modifierFlags parameter can be used to control what is acceptable in The
           list of ways. The string consists of a string of characters with each character
           representing the following:

               "s" = Allow single (individual) values
               "r" = Allow ranges of the form:
                           <start> ... <end>
               "l" = Allow loops of the form:
                           <start> TO <end> [ BY <step>]
                       The BY keyword and value are optional, and step is 1 if they are not
                       specified.
               "m" = Allow multiple instances of any of the allowable forms. Each instance
                       should be separated by a comma or one (or more) space.
           If there are no modifiers specified, then the default modifier string of "srlm"
           will be used.
           The resulting string will have new line tokens ("{\n}") wherever lines are to
           be broken.
           Note that this code supports a maximum of 1024 class variables (or Ways values
           from 0 to 1024).
           This function requires the functions getRuler() and skipSpaces().
        */
        function getWays(waysExp $, numClassVars, modifierFlags $) $ 4015;
            length
                modifiers $ 10
                errorMsg $ 4096;

            NLTOKEN = "{\n}";
            DIGITS = "0123456789";

            modifiers = ifc(modifierFlags = " ", "srlm", modifierFlags);

            /* List storage. */
            array list [1025] $ 1;
            if numClassVars >= dim(list) - 1 then do;
                errorMsg = tranwrd(tranwrd("ERROR: " || trim(%sysfunc(quote(&error_tooManyClassVars))), "{0}", trim(left(put(dim(list) - 1, best.)))), "{1}", trim(left(put(numClassVars, best.)))) || NLTOKEN || trim(getRuler(waysExp, nextChar));
                return (errorMsg);
            end;

            modCheck = findc(trim(lowcase(modifiers)), "srlm", "k");
            if modCheck NE 0 then do;
                errorMsg = tranwrd("ERROR: " || trim(%sysfunc(quote(&error_internalGetWaysError))) || " Invalid modifier character located in '{0}'. Valid modifiers are 'S' (single numbers), 'R' (ranges of numbers with ...), 'L' (to-by loops), and 'M' (multiple of each type).", "{0}", modifiers);
                return (errorMsg);
            end;

            allowMultiple = findc(modifiers, "mM") > 0;
            allowSingles = findc(modifiers, "sS") > 0;
            allowRanges = findc(modifiers, "rR") > 0;
            allowLoops = findc(modifiers, "lL") > 0;

            /* Initialize the variables used in parsing the ways string. */
            str = lowcase(waysExp);
            strLen = length(str);
            nextChar = str NE " "; /* nextChar will be a 0 or 1. */

            nextChar = skipSpaces(str, nextChar);

            /* Keep looping until the string is empty. */
            do while (nextChar NE 0);
                /* type: s = single, r = Loop, l = loop */
                type = "s";
                endOfNum = findc(str, DIGITS, "k", nextChar);
                if endOfNum = 0 then do;
                    /* The remainder of the string must be a number. */
                    endOfNum = length(str) + 1;
                end;
                if endOfNum = nextChar then do;
                    errorMsg = "ERROR: " || trim(%sysfunc(quote(&error_expectedAnInteger))) || NLTOKEN || trim(getRuler(waysExp, nextChar));
                    return (errorMsg);
                end;

                startNum = input(substr(str, nextChar, endOfNum - nextChar), 12.);
                /* Save the start position of the start value in case we need
                   it later for error messages. */
                startStartChar = nextChar;

                /* Skip over the start number in the string and any following spaces. */
                nextChar = skipSpaces(str, endOfNum);
                /* If there is more text, see if we have a Range or Loop. */
                if nextChar NE 0 then do;
                    if strLen >= nextChar + 3 AND substr(str, nextChar, 3) = "..." then do;
                        if allowRanges = 0 then do;
                            errorMsg = "ERROR: " || trim(%sysfunc(quote(&error_rangesNotAllowed))) || NLTOKEN || trim(getRuler(waysExp, nextChar));
                            return (errorMsg);
                        end;
                        type = "r";
                        /* skip over the "..." string and any following spaces. */
                        nextChar = skipSpaces(str, nextChar + 3);
                    end;
                    else do;
                        if strLen >= nextChar + 2 AND substr(str, nextChar, 2) = "to" then do;
                            if allowLoops = 0 then do;
                                errorMsg = "ERROR: " || trim(%sysfunc(quote(&error_loopsNotAllowed))) || NLTOKEN || trim(getRuler(waysExp, nextChar));
                                return (errorMsg);
                            end;
                            type = "l";
                            /* Skip over the "to" string and any following spaces. */
                            nextChar = skipSpaces(str, nextChar + 2);
                        end;
                    end;
                end;

                /* If we have a range or a loop we expect an end number next. */
                if type = "r" OR type = "l" then do;
                    if nextChar = 0 then do;
                        if type = "r" then do;
                            typeMsg = symget("error_badRangeEndValue");
                        end;
                        else do;
                            typeMsg = symget("error_badLoopEndValue");
                        end;
                        errorMsg = "ERROR: " || trim(typeMsg) || NLTOKEN || trim(getRuler(waysExp, length(waysExp) + 1));
                        return (errorMsg);
                    end;
                    endOfNum = findc(str, DIGITS, "k", nextChar);
                    if endOfNum = 0 then do;
                        /* The remainder of the string must be a number. */
                        endOfNum = strLen + 1;
                    end;
                    if endOfNum = nextChar then do;
                        if type = "r" then do;
                            typeMsg = symget("error_badRangeEndValue");
                        end;
                        else do;
                            typeMsg = symget("error_badLoopEndValue");
                        end;
                        errorMsg = "ERROR: " || trim(typeMsg) || NLTOKEN || trim(getRuler(waysExp, nextChar));
                        return (errorMsg);
                    end;
                    endNum = input(substr(str, nextChar, endOfNum - nextChar), 12.);
                    /* Save the start position of the end value in case we need
                       it later for error messages. */
                    endStartChar = nextChar;

                    /* Skip over the end number and any following spaces. */
                    nextChar = skipSpaces(str, endOfNum);
                    /* If we have a loop, there may be a by value. */
                    stepNum = .;
                    if type = "l" AND str NE " " then do;
                        if strLen >= nextChar + 2 and substr(str, nextChar, 2) = "by" then do;
                            /* Skip over the "by" string and any following spaces. */
                            nextChar = skipSpaces(str, nextChar + 2);
                            if nextChar = 0 then do;
                                errorMsg = "ERROR: " || trim(%sysfunc(quote(&error_badLoopByValue))) || NLTOKEN || trim(getRuler(waysExp, length(waysExp) + 1));
                                return (errorMsg);
                            end;

                            endOfNum = findc(str, DIGITS, "k", nextChar);
                            if endOfNum = 0 then do;
                                /* The remainder of the string must be a number. */
                                endOfNum = length(str) + 1;
                            end;
                            if endOfNum = nextChar then do;
                                errorMsg = "ERROR: " || trim(%sysfunc(quote(&error_badLoopByValue))) || NLTOKEN || trim(getRuler(waysExp, nextChar));
                                return (errorMsg);
                            end;
                            stepNum = input(substr(str, nextChar, endOfNum - nextChar), 12.);
                            /* Save the start position of the step value in case we need
                                it later for error messages. */
                            stepStartChar = nextChar;

                            /* Skip over the step number and any following spaces. */
                            nextChar = skipSpaces(str, endOfNum);
                        end;
                    end;
                end;
                else do;
                    if allowSingles = 0 then do;
                        errorMsg = "ERROR: " || trim(%sysfunc(quote(&error_indivValsNotAllowed))) || NLTOKEN || trim(getRuler(waysExp, startStartChar));
                        return (errorMsg);
                    end;
                end;

                /* Validate the numbers. */
                if type = "s" then do;
                    if startNum > numClassVars then do;
                        errorMsg = tranwrd(tranwrd("ERROR: " || trim(%sysfunc(quote(&error_valueTooBig))), "{0}", trim(left(put(startNum, best.)))), "{1}", trim(left(put(numClassVars, best.)))) || NLTOKEN || trim(getRuler(waysExp, startStartChar));
                        return (errorMsg);
                    end;
                    endNum = startNum;
                    stepNum = 1;
                end;
                else do;
                    if startNum > endNum then do;
                        if type = "r" then do;
                            typeMsg = symget("error_badRangeStartValue");
                        end;
                        else do;
                            typeMsg= symget("error_badLoopStartValue");
                        end;
                        errorMsg = tranwrd(tranwrd("ERROR: " || trim(typeMsg), "{0}", trim(left(put(startNum, best.)))), "{1}", trim(left(put(endNum, best.)))) || NLTOKEN || trim(getRuler(waysExp, startStartChar));
                        return (errorMsg);
                    end;
                    if endNum > numClassVars then do;
                        if type = "r" then do;
                            typeMsg = symget("error_rangeEndValueTooBig");
                        end;
                        else do;
                            typeMsg= symget("error_loopEndValueTooBig");
                        end;
                        errorMsg = tranwrd(tranwrd("ERROR: " || trim(typeMsg), "{0}", trim(left(put(endNum, best.)))), "{1}", trim(left(put(numClassVars, best.)))) || NLTOKEN || trim(getRuler(waysExp, endStartChar));
                        return (errorMsg);
                    end;
                    if type = "l" then do;
                        if stepNum = . then do;
                            stepNum = 1;
                        end;
                    end;
                    else do;
                        stepNum = 1;
                    end;
                end;

                if allowMultiple = 0 AND str NE " " then do;
                    errorMsg = "ERROR: " || trim(%sysfunc(quote(&error_multipleItemsNotAllowed))) || NLTOKEN || trim(getRuler(waysExp, nextChar));
                    return (errorMsg);
                end;

                /* There could now be an optional comma which we need to remove. */
                if nextChar NE 0  AND substr(str, nextChar, 1) = "," then do;
                    /* Skip over the optional comma character and any following spaces. */
                    nextChar = skipSpaces(str, nextChar + 1);
                end;

                /* Record the ways in the list. */
                do way = startNum + 1 to endNum + 1 by stepNum;
                    list[way] = "X";
                end;
            end; /* Main loop */

            /* Maximum characters needed for generating the ways digits:
                   0-9    10-99  100-999  1000-1024
                   10x2 + 90x3 + 900x4 + 25x5 = 4015 */
            length ways $ 4015;
            firstWay = 1;

            /* Generate the ways string */
            do way = 0 to dim(list) - 1;
                if list[way + 1] = "X" then do;
                    if firstWay = 1 then do;
                        firstWay = 0;
                        ways = left(put(way, 4.));
                    end;
                    else do;
                        ways = catx(" ", ways, put(way, 4.));
                    end;
                end;
            end;

            return (ways);
        endsub;

    run;

    /* Reset the MPRINT option back to its original setting. */
    OPTIONS &_mprintOption;

    /* ---------------- */
    /* -- Validation -- */

    %let __errorMsg_count = 0;

    /* A valid input table must have been selected */
    %__runtimeValidation(
        %eval(&inputData_lib = OR &inputData_name = ),
        %__tranmsg(&error_tableInfoIncomplete, %__formatLabel(&errorLabel_inputData))
    )

    /* If we are to generate a table a valid output table must have been selected */
    %let _outputTableError = %eval(&outputDS = 1 AND (&outputTable_lib = OR &outputTable_name = ));

    %__runtimeValidation(
        &_outputTableError,
        %__tranmsg(&error_tableInfoIncomplete, %__formatLabel(&errorLabel_outputData))
    )

    /* Output table related validations. */
    %if &_outputTableError = 0 %then %do;
        /* The "Input data" selector and "Output table" selector cannot specify the
           same data table. */
        %__runtimeValidation(
            %eval(
                &outputDS = 1 AND
                %superq(inputData) NE AND
                %superq(outputTable) NE AND
                %upcase(%superq(inputData)) = %upcase(%superq(outputTable))
            ),
            %__tranmsg(
                &error_tableSelectedTwice,
                %__formatLabel(&errorLabel_outputData),
                &outputTable_lib..&outputTable_name_base,
                %__formatLabel(&errorLabel_inputData)
            )
        )

        /* If the output data set starts from a '.' or ' ' or contains special
           characters /\*?"<>|:-, then we have an error condition and cannot
           proceed. */
        %__runtimeValidation(
            %eval(&outputDS = 1 AND %sysfunc(prxmatch(%bquote(/^(?![ .])[^><\/\\|*%str(%")?:-]{1,32}$/), &outputTable_name_base)) = 0),
            %__tranmsg(
                &error_badTableName,
                %__formatLabel(&errorLabel_outputData),
                &outputTable_name_base
            )
        )

        /* If the option to replace the output data set is not selected and
           the data set already exists, then we have an error condition and
           cannot proceed. */
        %__runtimeValidation(
            %eval(
                &outputDS = 1 AND
                &replaceOutputTable = 0 AND
                (%sysfunc(exist(%superq(outputTable), DATA)) OR %sysfunc(exist(%superq(outputTable), VIEW)))
            ),
            %__tranmsg(
                &error_cannotReplaceTable,
                %__formatLabel(&errorLabel_outputData),
                &outputTable_lib..&outputTable_name_base,
                %__formatLabel(&errorLabel_replaceOutputTable)
            )
        )
    %end;

    /* analysisVariable must have at least one variable selected. */
    %__runtimeValidation(
        %eval(&analysisVariables_count = 0),
        %__tranmsg(
            &error_atLeastOneVarReqd,
            %__formatLabel(&errorLabel_analysisVariables)
        )
    )

    /* Some form of output must be being produced. */
    %__runtimeValidation(
        %eval(&showStatistics = 0 AND &hist = 0 AND &boxPlot = 0 AND &outputDS = 0),
        &error_statOrPlotOrTableRequired
    )

    /* The custom confidence level must be greater than 0 and less than
       100. This test should not be necessary as we expect the numeric
       field control to catch any values out of range, so we should only
       ever get valid values. */
    %__runtimeValidation(
        %sysevalf(&conf = 1 AND &confLevel = confLevelCustomChoice AND (&confValue <= 0 OR &confValue >= 100)),
        %__tranmsg(
            &error_numInRangeGTLT,
            %__formatLabel(&errorLabel_confidenceValue),
            0,
            100
        )
    )

    /* Midpoints range and bins validations. */
    %if &hist = 1 AND &analysisVariables_count = 1 AND &midpoints = 1 %then %do;
        %if (&_hasClassVars = 1 AND &midpointsType = specify) OR
            (&_hasClassVars = 0 AND &noClassMidpointsType = specify) %then %do;
            /* The value for the midpoints start value must be less than or equal
            to the end value, */
            %__runtimeValidation(
                %sysevalf(&midpointsStart > &midpointsEnd),
                %__tranmsg(&error_midpointsStartGTEnd, &midpointsStart, &midpointsEnd)
            )

            /* The midpoints step number must be greater than zero. */
            %__runtimeValidation(
                %sysevalf(&midpointsStep <= 0),
                %__tranmsg(&error_midpointsStepLTZero, &midpointsStep)
            )
        %end;
        %if &_hasClassVars = 0 AND &noClassMidpointsType = bins %then %do;
            /* The midpoints bins number must be an integer greater than or equal to 2. */
            %__runtimeValidation(
                %sysevalf(&midpointsBins NE %sysfunc(int(&midpointsBins)) OR &midpointsBins < 2),
                %__tranmsg(&error_midpointsBinsInvalid, &midpointsBins)
            )
        %end;
    %end;

    /* If specific ways are to be used, we need to first check that the
       list of specific ways is valid, and that the largest value specified
       is not greater than the number of classification variables assigned. */
    %if &_hasClassVars = 1 AND &ways = specifyWays %then %do;
        %if (%sysevalf(&specifyWays NE)) %then %do;
            /* Save the current CMPLIB option setting. */
            %let _option_cmplib=%sysfunc(getoption(cmplib, keyword));
            /* Use our previously defined function library. */
            options cmplib=work._functions;

            /* Parse the Ways expression. */
            %let _wayValues = %sysfunc(getWays(&specifyWays, &classVariables_count, srlm));
            %if %length(%unquote(&_wayValues)) >= 8 %then %do;
                /* If we got an internal error, let the user know in their locale
                   but show the internal error message in English so that we can
                   understand what went wrong. */
                %__runtimeValidation(%sysevalf(%qsubstr(%quote(&_wayValues), 1, 5) = ERROR), %quote(&error_errorsInSpecificWays{\n}%qsubstr(%quote(&_wayValues), 8)))
            %end;

            /* Restore the CMPLIB option back to what it was previously. */
            options &_option_cmplib;
        %end;
        %else %do;
            %__runtimeValidation(%sysevalf(1 = 1), &error_specificWaysIsEmpty)
        %end;
    %end;

    /* If we have accumulated any error messages, handle them now and
       stop generating any step code. */
    %if &__errorMsg_count > 0 %then %do;
        /* Insert the localised step name into the generic message and change {1} to {0}
           within the string. */
        %__processErrors(%__tranmsg(&error_errorsInStep, &errorLabel_stepName, {0}))
        %return; /* This %RETURN statement is necessary - do not remove it. */
    %end;

    /* --------------------- */
    /* -- Code Generation -- */

    /* Convert the custom confidence level value from a percentage to a
       fraction (alpha value). */
    %let _alpha =;
    %if &conf = 1 %then %do;
        %if &confLevel = cf99 %then %do;
            %let _alpha = 0.01;
        %end;
        %else %if &confLevel = cf95 %then %do;
            %let _alpha = 0.05;
        %end;
        %else %if &confLevel = cf90 %then %do;
            %let _alpha = 0.1;
        %end;
        %else %do;
            %let _alpha = %sysevalf((100 - &confValue) / 100);
        %end;
    %end;

    %__code(%str(ods noproctitle))
    %__code(%str(ods graphics / imagemap=on))

    /* Generate the universal Footnotes */
    %__code(%str(footnote))

    %if &useDefaultFootnotes = 1 %then
        %let _rootTitleName = defaultFootnotesText;
    %else
        %let _rootTitleName = customFootnotes;

    %if %symexist(&_rootTitleName._count) = 1 %then %do;
        %let _maxLoops = &&&_rootTitleName._count;
        %if &_maxLoops > 10 %then %do;
            %let _maxLoops = 10;
        %end;
        %do _titleIdx = 1 %to &_maxLoops;
            %if %length(&&&_rootTitleName._&_titleIdx) > 0 %then %do;
                %__code(%str(footnote&_titleIdx %unquote(%sysfunc(quote(&&&_rootTitleName._&_titleIdx)))))
            %end;
        %end;
    %end;
    %else %do;
        %if %length(&&&_rootTitleName) > 0 %then %do;
            %__code(%str(footnote1 %unquote(%sysfunc(quote(&&&_rootTitleName)))))
        %end;
    %end;

    %if &showStatistics = 1 OR &outputDS = 1 OR &hist = 1 %then %do;
        %if &_hasByVars = 1 %then %do;
            %__code(%str(proc sort data=&inputData out=WORK._tempSorted))
            %__code(%str(by &byVariables))
            %__code(%str(run))
        %end;
    %end;

    /* ---------- */
    /* PROC MEANS */

    /* proc means code is generated only when at least one statistics is selected */
    %if &showStatistics = 1 OR &outputDS = 1 %then %do;
        %let _tempCode = ;
        %if &showStatistics = 1 %then %do;
            %if &maxDecimal NE bestFit %then %do;
                %let _tempCode = &_tempCode maxdec=&maxDecimal;
            %end;
            %if &copyVariables_count > 0 %then %do;
                %let _tempCode = &_tempCode printidvars;
                %if &copyValue = min %then %do;
                    %let _tempCode = &_tempCode idmin;
                %end;
            %end;
        %end;
        %else %do;
            %let _tempCode = &_tempCode noprint;
        %end;
        /* Show analysis labels */
        %if showLabels = 0 %then %do;
            %let _tempCode = &_tempCode nolabels;
        %end;
        /* ways set to n-way */
        %if &_hasClassVars = 1 AND &ways = nway %then %do;
            %let _tempCode = &_tempCode nway;
        %end;
        %else %do;
            /* ways set to all ways */
            %if &showStatistics = 1 AND &ways = allways %then %do;
                %let _tempCode = &_tempCode printalltypes;
            %end;
        %end;
        %if &mean = 1 %then %do; %let _tempCode = &_tempCode mean; %end;
        %if &std = 1 %then %do; %let _tempCode = &_tempCode std; %end;
        %if &min = 1 %then %do; %let _tempCode = &_tempCode min; %end;
        %if &max = 1 %then %do; %let _tempCode = &_tempCode max; %end;
        %if &median = 1 %then %do; %let _tempCode = &_tempCode median; %end;
        %if &nobs = 1 %then %do; %let _tempCode = &_tempCode n; %end; %else %do; %let _tempCode = &_tempCode nonobs; %end;
        %if &missing = 1 %then %do; %let _tempCode = &_tempCode nmiss; %end;
        %if &stdErr = 1 %then %do; %let _tempCode = &_tempCode stderr; %end;
        %if &variance = 1 %then %do; %let _tempCode = &_tempCode var; %end;
        %if &_hasWeightVar = 0 AND &mode = 1 %then %do; %let _tempCode = &_tempCode mode; %end;
        %if &range = 1 %then %do; %let _tempCode = &_tempCode range; %end;
        %if &sum = 1 %then %do; %let _tempCode = &_tempCode sum; %end;
        %if &_hasWeightVar = 1 AND &sumWeights = 1 %then %do; %let _tempCode = &_tempCode sumwgt; %end;

        %if &_useDivisor = 1 AND &divisor NE %then %do;
            %let _upcaseProp = %upcase(&divisor);
            %if &_upcaseProp = DDOF %then %do; %let _tempCode = &_tempCode vardef=df; %end;
            %else %if &_upcaseProp = DNOO %then %do; %let _tempCode = &_tempCode vardef=n; %end;
            %else %if &_upcaseProp = DSOWM1 %then %do; %let _tempCode = &_tempCode vardef=wdf; %end;
            %else %if &_upcaseProp = DSOW %then %do; %let _tempCode = &_tempCode vardef=wgt; %end;
        %end;

        %if &_useDivisorWgt = 1 AND &divisorWgt NE %then %do;
            %let _upcaseProp = %upcase(&divisorWgt);
            %if &_upcaseProp = DDOFWGT %then %do; %let _tempCode = &_tempCode vardef=df; %end;
            %else %if &_upcaseProp = DNOOWGT %then %do; %let _tempCode = &_tempCode vardef=n; %end;
            %else %if &_upcaseProp = DSOWM1WGT %then %do; %let _tempCode = &_tempCode vardef=wdf; %end;
            %else %if &_upcaseProp = DSOWWGT %then %do; %let _tempCode = &_tempCode vardef=wgt; %end;
        %end;

        %if &conf = 1 %then %do; %let _tempCode = &_tempCode clm alpha=&_alpha;  %end;
        %if &coef = 1 %then %do; %let _tempCode = &_tempCode cv; %end;
        %if &tstat = 1 %then %do; %let _tempCode = &_tempCode t probt; %end;
        %if &css = 1 %then %do; %let _tempCode = &_tempCode css; %end;
        %if &uss = 1 %then %do; %let _tempCode = &_tempCode uss; %end;
        %if &_hasWeightVar = 0 AND &skewness = 1 %then %do; %let _tempCode = &_tempCode skewness; %end;
        %if &_hasWeightVar = 0 AND &kurtosis = 1 %then %do; %let _tempCode = &_tempCode kurtosis; %end;
        %if &P1 = 1 %then %do; %let _tempCode = &_tempCode p1; %end;
        %if &P5 = 1 %then %do; %let _tempCode = &_tempCode p5; %end;
        %if &P10 = 1 %then %do; %let _tempCode = &_tempCode p10; %end;
        %if &Q1 = 1 %then %do; %let _tempCode = &_tempCode q1; %end;
        %if &Q3 = 1 %then %do; %let _tempCode = &_tempCode q3; %end;
        %if &P90 = 1 %then %do; %let _tempCode = &_tempCode p90; %end;
        %if &P95 = 1 %then %do; %let _tempCode = &_tempCode p95; %end;
        %if &P99 = 1 %then %do; %let _tempCode = &_tempCode p99; %end;
        %if &qrange = 1 %then %do; %let _tempCode = &_tempCode qrange; %end;
        %if &_useQuantiles = 1 AND &quantile NE %then %do;
            %if %upcase(&quantile) = QMOS %then %do; %let _tempCode = &_tempCode qmethod=os; %end;
            %else %do; %let _tempCode = &_tempCode qmethod=p2; %end;
        %end;
        %if &_useQuantilesWgt = 1 AND &quantileWgt NE %then %do;
            %if %upcase(&quantileWgt) = QMOSWGT %then %do; %let _tempCode = &_tempCode qmethod=os; %end;
            %else %do; %let _tempCode = &_tempCode qmethod=p2; %end;
        %end;

        /* There is no point in generating the TITLE statements for
           PROC MEANS if we are suppressing the printed PROC MEANS
           output. */
        %if &showStatistics = 1 %then %do;
            /* Generate PROC MEANS Titles */
            %__code(%str(title))

            %if &useDefaultAnalysisTitles = 1 %then
                %let _rootTitleName = defaultAnalysisTitlesText;
            %else
                %let _rootTitleName = customAnalysisTitles;

            %if %symexist(&_rootTitleName._count) = 1 %then %do;
                %let _maxLoops = &&&_rootTitleName._count;
                %if &_maxLoops > 10 %then %do;
                    %let _maxLoops = 10;
                %end;
                %do _titleIdx = 1 %to &_maxLoops;
                    %if %length(&&&_rootTitleName._&_titleIdx) > 0 %then %do;
                        %__code(%str(title&_titleIdx %unquote(%sysfunc(quote(&&&_rootTitleName._&_titleIdx)))))
                    %end;
                %end;
            %end;
            %else %do;
                %if %length(&&&_rootTitleName) > 0 %then %do;
                    %__code(%str(title1 %unquote(%sysfunc(quote(&&&_rootTitleName)))))
                %end;
            %end;
        %end;

        /* Generate the PROC MEANS specific statements. */
        %if &_hasByVars = 1 %then %do;
            %__code(%str(proc means data=WORK._tempSorted chartype &_tempCode))
        %end;
        %else %do;
            %__code(%str(proc means data=&inputData chartype &_tempCode))
        %end;
        %__code(%str(var &analysisVariables))
        %if &_hasClassVars = 1 %then %do;
            %__code(%str(class &classVariables))
        %end;
        /* Ways set to specific ways */
        %if &_hasClassVars = 1 AND &ways = specifyWays AND &_wayValues NE %then %do;
            %__code(%str(ways &_wayValues))
        %end;

        %if &outputDS = 1 %then %do;
            %let _tempCode =;
            %if &mean = 1 %then %do; %let _tempCode = &_tempCode mean=; %end;
            %if &std = 1 %then %do; %let _tempCode = &_tempCode std=; %end;
            %if &min = 1 %then %do; %let _tempCode = &_tempCode min=; %end;
            %if &max = 1 %then %do; %let _tempCode = &_tempCode max=; %end;
            %if &median = 1 %then %do; %let _tempCode = &_tempCode median=; %end;
            %if &nobs = 1 %then %do; %let _tempCode = &_tempCode n=; %end;
            %if &missing = 1 %then %do; %let _tempCode = &_tempCode nmiss=; %end;
            %if &stdErr = 1 %then %do; %let _tempCode = &_tempCode stderr=; %end;
            %if &variance = 1 %then %do; %let _tempCode = &_tempCode var=; %end;
            %if &_hasWeightVar = 0 AND &mode = 1 %then %do; %let _tempCode = &_tempCode mode=; %end;
            %if &range = 1 %then %do; %let _tempCode = &_tempCode range=; %end;
            %if &sum = 1 %then %do; %let _tempCode = &_tempCode sum=; %end;
            %if &_hasWeightVar=1 AND &sumWeights = 1 %then %do; %let _tempCode = &_tempCode sumwgt=; %end;
            %if &conf = 1 %then %do; %let _tempCode = &_tempCode lclm= uclm=; %end;
            %if &coef = 1 %then %do; %let _tempCode = &_tempCode cv=; %end;
            %if &tstat = 1 %then %do; %let _tempCode = &_tempCode t= probt=; %end;
            %if &css = 1 %then %do; %let _tempCode = &_tempCode css=; %end;
            %if &uss = 1 %then %do; %let _tempCode = &_tempCode uss=; %end;
            %if &_hasWeightVar = 0 AND &skewness = 1 %then %do; %let _tempCode = &_tempCode skewness=; %end;
            %if &_hasWeightVar = 0 AND &kurtosis = 1 %then %do; %let _tempCode = &_tempCode kurtosis=; %end;
            %if &P1 = 1 %then %do; %let _tempCode = &_tempCode p1=; %end;
            %if &P5 = 1 %then %do; %let _tempCode = &_tempCode p5=; %end;
            %if &P10 = 1 %then %do; %let _tempCode = &_tempCode p10=; %end;
            %if &Q1 = 1 %then %do; %let _tempCode = &_tempCode q1=; %end;
            %if &Q3 = 1 %then %do; %let _tempCode = &_tempCode q3=; %end;
            %if &P90 = 1 %then %do; %let _tempCode = &_tempCode p90=; %end;
            %if &P95 = 1 %then %do; %let _tempCode = &_tempCode p95=; %end;
            %if &P99 = 1 %then %do; %let _tempCode = &_tempCode p99=; %end;
            %if &qrange = 1 %then %do; %let _tempCode = &_tempCode qrange=; %end;
            %let _optionCode =;
            %if &classVariables_count > 1 %then %do;
                %let _opttionCode = %str( ways);
            %end;
            %__code(%str(output out=&outputTable &_tempCode / autoname autolabel inherit&_optionCode))
        %end;

        %if &freqVariable_count > 0 %then %do;
            %__code(%str(freq &freqVariable))
        %end;

        %if &_hasWeightVar = 1 %then %do;
            %__code(%str(weight &weightVariable))
        %end;

        %if &_hasByVars = 1 %then %do;
            %__code(%str(by &byVariables))
        %end;

        %if &copyVariables_count > 0 %then %do;
            %__code(%str(id &copyVariables))
        %end;

        %__code(%str(run))
    %end;

    /* PROC MEANS */
    /* ---------- */

    /* --------- */
    /* Histogram */

    %if &hist = 1 %then %do;
        /* Generate PROC UNIVARIATE (Histogram) Titles */
        %__code(%str(title))

        %if &useDefaultHistTitles = 1 %then
            %let _rootTitleName = defaultHistTitlesText;
        %else
            %let _rootTitleName = customHistTitles;

        %if %symexist(&_rootTitleName._count) = 1 %then %do;
            %let _maxLoops = &&&_rootTitleName._count;
            %if &_maxLoops > 10 %then %do;
                %let _maxLoops = 10;
            %end;
            %do _titleIdx = 1 %to &_maxLoops;
                %if %length(&&&_rootTitleName._&_titleIdx) > 0 %then %do;
                    %__code(%str(title&_titleIdx %unquote(%sysfunc(quote(&&&_rootTitleName._&_titleIdx)))))
                %end;
            %end;
        %end;
        %else %do;
            %if %length(&&&_rootTitleName) > 0 %then %do;
                %__code(%str(title1 %unquote(%sysfunc(quote(&&&_rootTitleName)))))
            %end;
        %end;

        %let _tempCode =;
        %if &_useDivisor = 1 AND &divisor NE %then %do;
            %let _upcaseProp = %UPCASE(&divisor);
            %if &_upcaseProp = DDOF %then %do; %let _tempCode = &_tempCode vardef=df; %end;
            %else %if &_upcaseProp = DNOO %then %do; %let _tempCode = &_tempCode vardef=n; %end;
            %else %if &_upcaseProp = DSOWM1 %then %do; %let _tempCode = &_tempCode vardef=wdf; %end;
            %else %if &_upcaseProp = DSOW %then %do; %let _tempCode = &_tempCode vardef=wgt; %end;
        %end;

        %if &_useDivisorWgt = 1 AND &divisorWgt NE %then %do;
            %let _upcaseProp = %UPCASE(&divisorWgt);
            %if &_upcaseProp = DDOFWGT %then %do; %let _tempCode = &_tempCode vardef=df; %end;
            %else %if &_upcaseProp = DNOOWGT %then %do; %let _tempCode = &_tempCode vardef=n; %end;
            %else %if &_upcaseProp = DSOWM1WGT %then %do; %let _tempCode = &_tempCode vardef=wdf; %end;
            %else %if &_upcaseProp = DSOWWGT %then %do; %let _tempCode = &_tempCode vardef=wgt; %end;
        %end;
        %if &_hasByVars = 1 %then %do;
            %__code(%str(proc univariate data=WORK._tempSorted noprint &_tempCode))
        %end;
        %else %do;
            %__code(%str(proc univariate data=&inputData noprint &_tempCode))
        %end;
        %if &analysisVariables_count > 0 %then %do;
            %__code(%str(var &analysisVariables))
        %end;

        %if &_hasClassVars = 1 %then %do;
            %__code(%str(class &classVariables))
        %end;

        %let _tempCode =;
        %if &normalDensityPlot = 1 OR &kernelDensityPlot = 1 %then %do;
            %if &normalDensityPlot = 1 %then %do; %let _tempCode = &_tempCode normal(noprint); %end;
            %if &kernelDensityPlot = 1 %then %do; %let _tempCode = &_tempCode kernel; %end;
        %end;
        %if &analysisVariables_count = 1 AND &midpoints = 1 %then %do;
            %if (&_hasClassVars = 1 AND &midpointsType = specify) OR
                (&_hasClassVars = 0 AND &noClassMidpointsType = specify) %then %do;
                %let _tempCode = &_tempCode midpoints=&midpointsStart to &midpointsEnd by &midpointsStep;
            %end;
            %else %do;
                %if &_hasClassVars = 0 AND &noClassMidpointsType = bins %then %do;
                    %let _tempCode = &_tempCode nmidpoints=&midpointsBins;
                %end;
                %else %do;
                    %let _tempCode = &_tempCode midpoints=&midpointsType;
                %end;
            %end;
        %end;
        /* If we have histogram options, prefix them with the slash. */
        %if %quote(&_tempCode) NE %then %do;
            %let _tempCode = %str( / &_tempCode);
        %end;
        %__code(%str(histogram &analysisVariables&_tempCode))

        %if &histogramInset = 1 %then %do;
            /* &_statsSelected cannot be used here as the inset doesn't show
               confidence limits (&conf = 1). */
            %if &mean = 1 OR &std = 1 OR &min = 1 OR &max = 1 OR &nobs = 1 OR &missing = 1 OR
                &stdErr = 1 OR &variance = 1 OR &mode = 1 OR &range = 1 OR
                &sum = 1 OR &coef = 1 OR
                &tstat = 1 OR &css = 1 OR &uss = 1 OR
                &skewness = 1 OR &kurtosis = 1 OR &P1 = 1 OR &P5 = 1 OR
                &P10 = 1 OR &Q1 = 1 OR &median = 1 OR &Q3 = 1 OR &P90 = 1 OR
                &P95 = 1 OR &P99 = 1 OR &qrange = 1 %then %do;
                %let _tempCode =;
                %if &mean = 1 %then %do; %let _tempCode = &_tempCode mean; %end;
                %if &std = 1 %then %do; %let _tempCode = &_tempCode std; %end;
                %if &min = 1 %then %do; %let _tempCode = &_tempCode min; %end;
                %if &max = 1 %then %do; %let _tempCode = &_tempCode max; %end;
                %if &median = 1 %then %do; %let _tempCode = &_tempCode median; %end;
                %if &nobs = 1 %then %do; %let _tempCode = &_tempCode n; %end;
                %if &missing = 1 %then %do; %let _tempCode = &_tempCode nmiss; %end;
                %if &stdErr = 1 %then %do; %let _tempCode = &_tempCode stderr; %end;
                %if &variance = 1 %then %do; %let _tempCode = &_tempCode var; %end;
                %if &mode = 1 %then %do; %let _tempCode = &_tempCode mode; %end;
                %if &range = 1 %then %do; %let _tempCode = &_tempCode range; %end;
                %if &sum = 1 %then %do; %let _tempCode = &_tempCode sum; %end;
                %if &coef = 1 %then %do; %let _tempCode = &_tempCode cv; %end;
                %if &tstat = 1 %then %do; %let _tempCode = &_tempCode t probt; %end;
                %if &css = 1 %then %do; %let _tempCode = &_tempCode css; %end;
                %if &uss = 1 %then %do; %let _tempCode = &_tempCode uss; %end;
                %if &skewness = 1 %then %do; %let _tempCode = &_tempCode skewness; %end;
                %if &kurtosis = 1 %then %do; %let _tempCode = &_tempCode kurtosis; %end;
                %if &P1 = 1 %then %do; %let _tempCode = &_tempCode p1; %end;
                %if &P5 = 1 %then %do; %let _tempCode = &_tempCode p5; %end;
                %if &P10 = 1 %then %do; %let _tempCode = &_tempCode p10; %end;
                %if &Q1 = 1 %then %do; %let _tempCode = &_tempCode q1; %end;
                %if &Q3 = 1 %then %do; %let _tempCode = &_tempCode q3; %end;
                %if &P90 = 1 %then %do; %let _tempCode = &_tempCode p90; %end;
                %if &P95 = 1 %then %do; %let _tempCode = &_tempCode p95; %end;
                %if &P99 = 1 %then %do; %let _tempCode = &_tempCode p99; %end;
                %if &qrange = 1 %then %do; %let _tempCode = &_tempCode qrange; %end;
                %let _tempCode = &_tempCode / position=;
                %if &histogramInsetPosition = histogramInsetPositionN %then %do; %let _tempCode = &_tempCode.n; %end;
                %else %if &histogramInsetPosition = histogramInsetPositionNE %then %do; %let _tempCode = &_tempCode.ne; %end;
                %else %if &histogramInsetPosition = histogramInsetPositionE %then %do; %let _tempCode = &_tempCode.e; %end;
                %else %if &histogramInsetPosition = histogramInsetPositionSE %then %do; %let _tempCode = &_tempCode.se; %end;
                %else %if &histogramInsetPosition = histogramInsetPositionS %then %do; %let _tempCode = &_tempCode.s; %end;
                %else %if &histogramInsetPosition = histogramInsetPositionSW %then %do; %let _tempCode = &_tempCode.sw; %end;
                %else %if &histogramInsetPosition = histogramInsetPositionW %then %do; %let _tempCode = &_tempCode.w; %end;
                %else %if &histogramInsetPosition = histogramInsetPositionNW %then %do; %let _tempCode = &_tempCode.nw; %end;

                %__code(%str(inset &_tempCode))
            %end;
        %end;

        %if &freqVariable_count > 0 %then %do;
            %__code(%str(freq &freqVariable))
        %end;

        %if &_hasByvars = 1 %then %do;
            %__code(%str(by &byVariables))
        %end;
        %__code(%str(run))
    %end;

    /* Histogram */
    /* --------- */

    /* -------- */
    /* Box Plot */

    %if &boxPlot = 1 %then %do;
        /* Generate PROC BOXPLOT Titles */
        %__code(%str(title))

        %if &useDefaultBoxPlotTitles = 1 %then
            %let _rootTitleName = defaultBoxPlotTitlesText;
        %else
            %let _rootTitleName = customBoxPlotTitles;

        %if %symexist(&_rootTitleName._count) = 1 %then %do;
            %let _maxLoops = &&&_rootTitleName._count;
            %if &_maxLoops > 10 %then %do;
                %let _maxLoops = 10;
            %end;
            %do _titleIdx = 1 %to &_maxLoops;
                %if %length(&&&_rootTitleName._&_titleIdx) > 0 %then %do;
                    %__code(%str(title&_titleIdx %unquote(%sysfunc(quote(&&&_rootTitleName._&_titleIdx)))))
                %end;
            %end;
        %end;
        %else %do;
            %if %length(&&&_rootTitleName) > 0 %then %do;
                %__code(%str(title1 %unquote(%sysfunc(quote(&&&_rootTitleName)))))
            %end;
        %end;

        %let _boxplotCount = 1;
        %if &_hasClassVars = 1 %then %do;
            %let _boxplotCount = &classVariables_count;
        %end;
        %do _classVarIndex=1 %to &_boxplotCount;
            %if &_hasClassVars = 1 %then %do;
                %let _classVar=%str(&&classVariables_&_classVarIndex._name);
            %end;
            %else %do;
                %let _classVar=%str("All Obs."n);
                %__code(data work._tempNoClass)
                %__code(set &inputData)
                %__code(&_classVar=".")
                %__code(run)
                %let inputData=%str(work._tempNoClass);
            %end;
            %__code(%str(proc sort data=&inputData out=WORK._tempSorted))
            %if &_hasByVars = 1 %then %do;
                %__code(%str(by &byVariables &_classVar))
            %end;
            %else %do;
                %__code(%str(by &_classVar))
            %end;
            %__code(%str(run))
            %let _tempCode =;
            %if &_hasClassVars = 0 %then %do;
                /* If there is no class variable then we need to format the
                   box plot a little by specifying these options. */
                %let _tempCode = nohlabel;
            %end;
            %__code(%str(proc boxplot data=WORK._tempSorted))
            %__code(%str(plot (&analysisVariables) * &_classVar / boxstyle=schematic &_tempCode))
            /* Inset */
            %if &boxPlotInset = 1 %then %do;
                %if &mean = 1 OR &std = 1 OR &min = 1 OR &max = 1 OR &nobs = 1 %then %do;
                    %let _tempCode =;
                    %if &mean = 1 %then %do; %let _tempCode = &_tempCode mean; %end;
                    %if &std = 1 %then %do; %let _tempCode = &_tempCode stddev; %end;
                    %if &min = 1 %then %do; %let _tempCode = &_tempCode min; %end;
                    %if &max = 1 %then %do; %let _tempCode = &_tempCode max; %end;
                    %if &nobs = 1 %then %do; %let _tempCode = &_tempCode nobs; %end;
                    %let _tempCode = &_tempCode / position=;
                    %if &boxPlotInsetPosition = boxPlotInsetPositionN %then %do; %let _tempCode = &_tempCode.n; %end;
                    %else %if &boxPlotInsetPosition = boxPlotInsetPositionNE %then %do; %let _tempCode = &_tempCode.ne; %end;
                    %else %if &boxPlotInsetPosition = boxPlotInsetPositionE %then %do; %let _tempCode = &_tempCode.e; %end;
                    %else %if &boxPlotInsetPosition = boxPlotInsetPositionSE %then %do; %let _tempCode = &_tempCode.se; %end;
                    %else %if &boxPlotInsetPosition = boxPlotInsetPositionS %then %do; %let _tempCode = &_tempCode.s; %end;
                    %else %if &boxPlotInsetPosition = boxPlotInsetPositionSW %then %do; %let _tempCode = &_tempCode.sw; %end;
                    %else %if &boxPlotInsetPosition = boxPlotInsetPositionW %then %do; %let _tempCode = &_tempCode.w; %end;
                    %else %if &boxPlotInsetPosition = boxPlotInsetPositionNW %then %do; %let _tempCode = &_tempCode.nw; %end;
                    %__code(%str(inset &_tempCode))
                %end;
            %end;
            /* Group Inset */
            %if &_hasClassVars = 1 AND &boxPlotGroupInset = 1 %then %do;
                %if &mean = 1 OR &std = 1 OR &min = 1 OR &max = 1 OR &nobs = 1 OR &Q1 = 1 OR &median = 1 OR &Q3= 1 OR &range= 1 %then %do;
                    %let _tempCode =;
                    %if &mean = 1 %then %do; %let _tempCode = &_tempCode mean; %end;
                    %if &std = 1 %then %do; %let _tempCode = &_tempCode stddev; %end;
                    %if &min = 1 %then %do; %let _tempCode = &_tempCode min; %end;
                    %if &max = 1 %then %do; %let _tempCode = &_tempCode max; %end;
                    %if &nobs = 1 %then %do; %let _tempCode = &_tempCode n; %end;
                    %if &Q1 = 1 %then %do; %let _tempCode = &_tempCode q1; %end;
                    %if &median = 1 %then %do; %let _tempCode = &_tempCode q2; %end;
                    %if &Q3 = 1 %then %do; %let _tempCode = &_tempCode q3; %end;
                    %if &range = 1 %then %do; %let _tempCode = &_tempCode range; %end;
                    %let _tempCode = &_tempCode / position=;
                    %if &boxPlotGroupInsetPosition = boxPlotGroupInsetPositionTop %then %do; %let _tempCode = &_tempCode.top; %end;
                    %else %if &boxPlotGroupInsetPosition = boxPlotGroupInsetPositionTopoff %then %do; %let _tempCode = &_tempCode.topoff; %end;
                    %else %if &boxPlotGroupInsetPosition = boxPlotGroupInsetPositionAxis %then %do; %let _tempCode = &_tempCode.axis; %end;
                    %else %if &boxPlotGroupInsetPosition = boxPlotGroupInsetPositionBottom %then %do; %let _tempCode = &_tempCode.bottom; %end;
                    %__code(%str(insetgroup &_tempCode))
                %end;
            %end;
            %if &_hasByVars = 1 %then %do;
                %__code(%str(by &byVariables))
            %end;
            %__code(%str(run))
        %end;
    %end;

    /* Box Plot */
    /* -------- */

    /* -------- */
    /* Clean up */

    %if &showStatistics = 1 OR &hist = 1 OR &boxPlot = 1 %then %do;
        %__code(title)
        %__code(footnote)
    %end;

    options cmplib=work._functions;
    proc fcmp outlib=work._functions.func;
        deletefunc prepareErrorForLog;
        deletefunc skipSpaces;
        deletefunc getWays;
        deletesubr getRuler;
    run;
    options &_option_cmplib;

    %if &_hasByVars = 1 OR &boxPlot = 1 OR %sysfunc(exist(work._functions, DATA)) %then %do;
        %__code(%str(proc datasets library=WORK nolist nowarn memtype = (data view)))
        %let _tempCode =;
        %if &_hasByVars = 1 %then %do;
            %let _tempCode = &_tempCode _tempSorted;
        %end;
        %else %do;
            %if &boxPlot=1 %then %do;
                %let _tempCode = &_tempCode _tempSorted;
            %end;
        %end;
        %if &boxPlot = 1 AND &_hasClassVars = 0 %then %do;
            %let _tempCode = &_tempCode _tempNoClass;
        %end;
        %if %sysfunc(exist(work._functions, DATA)) %then %do;
            %let _tempCode = &_tempCode _functions;
        %end;
        %__code(%str(delete &_tempCode))
        %__code(%str(run))
    %end;

    /* Create an empty table to workaround the server including tables
       that have been deleted in the list of output tables. */
    data work._functions;
        note = symget("utilityTableMainNote");
        output;
  stop;
    run;

/* Clean up */
/* -------- */

%mend runStep;

/* ************************************************************************* */
/* Main entry point: All the work is done in the macro. */
%let __locallyDefinedEntryPointMacro = 0;
%if %sysmacexist(__entryPoint) = 0 %then %do;
    %let __locallyDefinedEntryPointMacro = 1;
    %macro __entryPoint();
        %runStep()
    %mend __entryPoint;
%end;

options mprint;
%__entryPoint()

/* ************************************************************************* */
/* Tidy up macros and macro variables that have been defined. */
%sysmacdelete __formatLabel;
%sysmacdelete __tranmsg;

/* If we created a local __entryPoint macro, remove it. */
%if &__locallyDefinedEntryPointMacro = 1 %then %do;
    %sysmacdelete __entryPoint;
%end;
%symdel __locallyDefinedEntryPointMacro;

/* If we created a local __processErrors macro, remove it. */
%if &__locallyDefinedProcErrsMacro = 1 %then %do;
    %sysmacdelete __processErrors;
%end;
%symdel __locallyDefinedProcErrsMacro;

/* If we created a local __code macro, remove it. */
%if &__locallyDefinedCodeMacro = 1 %then %do;
    %sysmacdelete __code;
%end;
%symdel __locallyDefinedCodeMacro;

/* SAS code provided in template section of Custom Step - END */

/* region: Generated macro cleanup */

/* Cleanup macros and macro variables - BEGIN */
/* Delete macro variables created in this step */

%_flw_del_macro_vars( P1 );
%_flw_del_macro_vars( P10 );
%_flw_del_macro_vars( P5 );
%_flw_del_macro_vars( P90 );
%_flw_del_macro_vars( P95 );
%_flw_del_macro_vars( P99 );
%_flw_del_macro_vars( Q1 );
%_flw_del_macro_vars( Q3 );
%_flw_del_macro_vars( analysisVariables analysisVariables_count analysisVariables_1_format analysisVariables_1_informat analysisVariables_1_label analysisVariables_1_name
                  analysisVariables_1_name_base analysisVariables_1_rawlength analysisVariables_1_type analysisVariables_2_format analysisVariables_2_informat analysisVariables_2_label
                  analysisVariables_2_name analysisVariables_2_name_base analysisVariables_2_rawlength analysisVariables_2_type analysisVariables_3_format analysisVariables_3_informat
                  analysisVariables_3_label analysisVariables_3_name analysisVariables_3_name_base analysisVariables_3_rawlength analysisVariables_3_type analysisVariables_4_format
                  analysisVariables_4_informat analysisVariables_4_label analysisVariables_4_name analysisVariables_4_name_base analysisVariables_4_rawlength analysisVariables_4_type
                  analysisVariables_5_format analysisVariables_5_informat analysisVariables_5_label analysisVariables_5_name analysisVariables_5_name_base analysisVariables_5_rawlength
                  analysisVariables_5_type );
%_flw_del_macro_vars( boxPlot );
%_flw_del_macro_vars( boxPlotGroupInset );
%_flw_del_macro_vars( boxPlotGroupInsetPosition );
%_flw_del_macro_vars( boxPlotInset );
%_flw_del_macro_vars( boxPlotInsetPosition );
%_flw_del_macro_vars( byVariables byVariables_count );
%_flw_del_macro_vars( classVariables classVariables_count );
%_flw_del_macro_vars( coef );
%_flw_del_macro_vars( conf );
%_flw_del_macro_vars( confLevel );
%_flw_del_macro_vars( confValue );
%_flw_del_macro_vars( copyValue );
%_flw_del_macro_vars( copyVariables copyVariables_count );
%_flw_del_macro_vars( css );
%_flw_del_macro_vars( customAnalysisTitles );
%_flw_del_macro_vars( customBoxPlotTitles );
%_flw_del_macro_vars( customFootnotes );
%_flw_del_macro_vars( customHistTitles );
%_flw_del_macro_vars( defaultAnalysisTitlesText defaultAnalysisTitlesText_count defaultAnalysisTitlesText_1 defaultAnalysisTitlesText_2 );
%_flw_del_macro_vars( defaultBoxPlotTitlesText defaultBoxPlotTitlesText_count defaultBoxPlotTitlesText_1 defaultBoxPlotTitlesText_2 );
%_flw_del_macro_vars( defaultFootnotesText );
%_flw_del_macro_vars( defaultHistTitlesText defaultHistTitlesText_count defaultHistTitlesText_1 defaultHistTitlesText_2 );
%_flw_del_macro_vars( divisor );
%_flw_del_macro_vars( divisorWgt );
%_flw_del_macro_vars( errorLabel_analysisVariables );
%_flw_del_macro_vars( errorLabel_confidenceValue );
%_flw_del_macro_vars( errorLabel_inputData );
%_flw_del_macro_vars( errorLabel_outputData );
%_flw_del_macro_vars( errorLabel_replaceOutputTable );
%_flw_del_macro_vars( errorLabel_stepName );
%_flw_del_macro_vars( error_atLeastOneVarReqd );
%_flw_del_macro_vars( error_badLoopByValue );
%_flw_del_macro_vars( error_badLoopEndValue );
%_flw_del_macro_vars( error_badLoopStartValue );
%_flw_del_macro_vars( error_badRangeEndValue );
%_flw_del_macro_vars( error_badRangeStartValue );
%_flw_del_macro_vars( error_badTableName );
%_flw_del_macro_vars( error_cannotReplaceTable );
%_flw_del_macro_vars( error_errorsInSpecificWays );
%_flw_del_macro_vars( error_errorsInStep );
%_flw_del_macro_vars( error_expectedAnInteger );
%_flw_del_macro_vars( error_indivValsNotAllowed );
%_flw_del_macro_vars( error_internalGetWaysError );
%_flw_del_macro_vars( error_loopEndValueTooBig );
%_flw_del_macro_vars( error_loopsNotAllowed );
%_flw_del_macro_vars( error_midpointsBinsInvalid );
%_flw_del_macro_vars( error_midpointsStartGTEnd );
%_flw_del_macro_vars( error_midpointsStepLTZero );
%_flw_del_macro_vars( error_multipleItemsNotAllowed );
%_flw_del_macro_vars( error_numInRangeGTLT );
%_flw_del_macro_vars( error_rangeEndValueTooBig );
%_flw_del_macro_vars( error_rangesNotAllowed );
%_flw_del_macro_vars( error_specificWaysIsEmpty );
%_flw_del_macro_vars( error_statOrPlotNeeded );
%_flw_del_macro_vars( error_statOrPlotOrTableRequired );
%_flw_del_macro_vars( error_tableInfoIncomplete );
%_flw_del_macro_vars( error_tableSelectedTwice );
%_flw_del_macro_vars( error_tooManyClassVars );
%_flw_del_macro_vars( error_valueTooBig );
%_flw_del_macro_vars( freqVariable freqVariable_count );
%_flw_del_macro_vars( hist );
%_flw_del_macro_vars( histogramInset );
%_flw_del_macro_vars( histogramInsetPosition );
%_flw_del_macro_vars( inputData inputData_engine inputData_label inputData_lib inputData_name inputData_name_base
                  inputData_type );
%_flw_del_macro_vars( kernelDensityPlot );
%_flw_del_macro_vars( kurtosis );
%_flw_del_macro_vars( max );
%_flw_del_macro_vars( maxDecimal );
%_flw_del_macro_vars( mean );
%_flw_del_macro_vars( median );
%_flw_del_macro_vars( midpoints );
%_flw_del_macro_vars( midpointsBins );
%_flw_del_macro_vars( midpointsEnd );
%_flw_del_macro_vars( midpointsStart );
%_flw_del_macro_vars( midpointsStep );
%_flw_del_macro_vars( midpointsType );
%_flw_del_macro_vars( min );
%_flw_del_macro_vars( missing );
%_flw_del_macro_vars( mode );
%_flw_del_macro_vars( noClassMidpointsType );
%_flw_del_macro_vars( nobs );
%_flw_del_macro_vars( normalDensityPlot );
%_flw_del_macro_vars( outputDS );
%_flw_del_macro_vars( outputTable outputTable_engine outputTable_label outputTable_lib outputTable_name outputTable_name_base
                  outputTable_type );
%_flw_del_macro_vars( qrange );
%_flw_del_macro_vars( quantile );
%_flw_del_macro_vars( quantileWgt );
%_flw_del_macro_vars( range );
%_flw_del_macro_vars( replaceOutputTable );
%_flw_del_macro_vars( showLabels );
%_flw_del_macro_vars( showStatistics );
%_flw_del_macro_vars( skewness );
%_flw_del_macro_vars( specifyWays );
%_flw_del_macro_vars( std );
%_flw_del_macro_vars( stdErr );
%_flw_del_macro_vars( sum );
%_flw_del_macro_vars( sumWeights );
%_flw_del_macro_vars( tstat );
%_flw_del_macro_vars( useDefaultAnalysisTitles );
%_flw_del_macro_vars( useDefaultBoxPlotTitles );
%_flw_del_macro_vars( useDefaultFootnotes );
%_flw_del_macro_vars( useDefaultHistTitles );
%_flw_del_macro_vars( uss );
%_flw_del_macro_vars( utilityTableErrorsNote );
%_flw_del_macro_vars( utilityTableMainNote );
%_flw_del_macro_vars( variance );
%_flw_del_macro_vars( ways );
%_flw_del_macro_vars( weightVariable weightVariable_count );
/* Delete macros defined in this step */
%_flw_del_macros(_flw_get_column_list _flw_del_macro_vars);

/* Cleanup macros and macro variables - END */

%sysmacdelete _flw_del_macros;

/* endregion */


/* region: Generated step cleanup for Summary Statistics */
%_flw_action_end(id-1750923024531-2944, WORK._flw17509230245312944_0_0_4, WORK, "_flw17509230245312944_0_0_4");
/* endregion */

/*===========================================================================*
* Node name:        Bar Chart
* Node ID:          id-1750923014674-2862
*
* Input Tables:
*   WORK.Final
*
* Step name:        Bar Chart
* Step path:        /dataFlows/steps/20da0050-45c0-4045-9776-0edb04835385
* Step description: 
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1750923014674-2862);
/* endregion */

/* region: Generated macro initialization */

/* Define utility macros - BEGIN */

/* Macro to get a list of column names */
%macro _flw_get_column_list(_flw_prefix = %nrstr(), _delim=%str( ));
   %do _flw_index=1 %to %unquote(&&&_flw_prefix._count);%unquote(&&&_flw_prefix._&_flw_index._name)%if &_flw_index.<%unquote(&&&_flw_prefix._count)%then&_delim.; %end;
%mend;

/* Macro to delete macro variables with names passed in */
%macro _flw_del_macro_vars(_flw_macro_vars_to_delete,_flw_no_warn=Y);
   %if "&_flw_no_warn"="Y" %then %symdel &_flw_macro_vars_to_delete/NOWARN;
   %else %symdel &_flw_macro_vars_to_delete;
%mend;

/* Macro to delete a list of macros with names passed in */
%macro _flw_del_macros(_flw_macro_names,_flw_no_warn=Y);
   %let num=1;
   %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %do %while (&_flw_local_macros_to_delete ne );
      %if "&_flw_no_warn"="Y" %then %sysmacdelete &_flw_local_macros_to_delete/NOWARN;
      %else %sysmacdelete &_flw_local_macros_to_delete;
      %let num=%eval(&num+1);
      %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %end;
%mend;

/* Define utility macros - END */

/* Macro variables derived from user input to this step - BEGIN */

/* Macro variable(s) for UI control with ID of barColor */
%let barColor=CAD5E5;

/* Macro variable(s) for UI control with ID of barLimitStat */
%let barLimitStat=clm;

/* Macro variable(s) for UI control with ID of barLimits */
%let barLimits=none;

/* Macro variable(s) for UI control with ID of barNumStd */
%let barNumStd=1;

/* Macro variable(s) for UI control with ID of barNumStdChkbox */
%let barNumStdChkbox=0;

/* Macro variable(s) for UI control with ID of barOrient */
%let barOrient=vertical;

/* Macro variable(s) for UI control with ID of barSkin */
%let barSkin=none;

/* Macro variable(s) for UI control with ID of barStatLabels */
%let barStatLabels=0;

/* Macro variable(s) for UI control with ID of barTrans */
%let barTrans=0;

/* Macro variable(s) for UI control with ID of byVar */
%let byVar=;
%let byVar_count=0;

/* Macro variable(s) for UI control with ID of catLabel */
%let catLabel=;

/* Macro variable(s) for UI control with ID of catLabelRotation */
%let catLabelRotation=0;

/* Macro variable(s) for UI control with ID of catRefCustomLabel */
%let catRefCustomLabel=;

/* Macro variable(s) for UI control with ID of catRefLabel */
%let catRefLabel=catRefValue;

/* Macro variable(s) for UI control with ID of catRefLine */
%let catRefLine=0;

/* Macro variable(s) for UI control with ID of catRefLineOffset */
%let catRefLineOffset=0;

/* Macro variable(s) for UI control with ID of catRefLineValue */
%let catRefLineValue=;

/* Macro variable(s) for UI control with ID of catReverse */
%let catReverse=0;

/* Macro variable(s) for UI control with ID of catTickRotate */
%let catTickRotate=catDiagonalRotation;

/* Macro variable(s) for UI control with ID of category */
%let category=loan_status;
%let category_count=1;

/* Macro variables for column <loan_status> */
%let category_1_format=$18.;
%let category_1_informat=$18.;
%let category_1_label=;
%let category_1_name=loan_status;
%let category_1_name_base=loan_status;
%let category_1_rawlength=18;
%let category_1_type=Character;

/* Macro variable(s) for UI control with ID of cmHeight */
%let cmHeight=12;

/* Macro variable(s) for UI control with ID of cmWidth */
%let cmWidth=16;

/* Macro variable(s) for UI control with ID of confLevel */
%let confLevel=95;

/* Macro variable(s) for UI control with ID of confLevelCombo */
%let confLevelCombo=confLevelDefaultChoice;

/* Macro variable(s) for UI control with ID of dataSource */
%let dataSource=WORK.Final;
%let dataSource_engine=V9;
%let dataSource_label=;
%let dataSource_lib=WORK;
%let dataSource_name=Final;
%let dataSource_name_base=Final;
%let dataSource_type=;

/* Macro variable(s) for UI control with ID of dimType */
%let dimType=%nrquote(in);

/* Macro variable(s) for UI control with ID of displayCatLabel */
%let displayCatLabel=defaultLabel;

/* Macro variable(s) for UI control with ID of displayRespLabel1 */
%let displayRespLabel1=defaultLabel;

/* Macro variable(s) for UI control with ID of displayRespLabel2 */
%let displayRespLabel2=defaultLabel;

/* Macro variable(s) for UI control with ID of errorLabel_category */
%let errorLabel_category=Category:;

/* Macro variable(s) for UI control with ID of errorLabel_measure */
%let errorLabel_measure=%nrquote(Measure variable:);

/* Macro variable(s) for UI control with ID of errorLabel_stepName */
%let errorLabel_stepName=%nrquote(Bar Chart);

/* Macro variable(s) for UI control with ID of error_cmHeightInvalidRange */
%let error_cmHeightInvalidRange=%nrquote(%'Graph size height%' requires a number greater than or equal to 5 and less than or equal to 30 for the height in centimeters.);

/* Macro variable(s) for UI control with ID of error_cmWidthInvalidRange */
%let error_cmWidthInvalidRange=%nrquote(%'Graph size width%' requires a number greater than or equal to 5 and less than or equal to 30 for the width in centimeters.);

/* Macro variable(s) for UI control with ID of error_errorsInStep */
%let error_errorsInStep=%nrquote(The {0} step contained the following {1} errors and could not be run:);

/* Macro variable(s) for UI control with ID of error_inchHeightInvalidRange */
%let error_inchHeightInvalidRange=%nrquote(%'Graph size height%' requires a number greater than or equal to 2 and less than or equal to 12 for the height in inches.);

/* Macro variable(s) for UI control with ID of error_inchWidthInvalidRange */
%let error_inchWidthInvalidRange=%nrquote(%'Graph size width%' requires a number greater than or equal to 2 and less than or equal to 12 for the width in inches.);

/* Macro variable(s) for UI control with ID of error_invalidMeasureAxis */
%let error_invalidMeasureAxis=%nrquote(The maximum value of measure axis should be greater than or equal to the minimum value of measure axis.);

/* Macro variable(s) for UI control with ID of error_pixelHeightInvalidRange */
%let error_pixelHeightInvalidRange=%nrquote(%'Graph size height%' requires an integer greater than or equal to 200 and less than or equal to 1200 for the height in pixels.);

/* Macro variable(s) for UI control with ID of error_pixelWidthInvalidRange */
%let error_pixelWidthInvalidRange=%nrquote(%'Graph size width%' requires an integer greater than or equal to 200 and less than or equal to 1200 for the width in pixels.);

/* Macro variable(s) for UI control with ID of error_variableRequired */
%let error_variableRequired=%nrquote({0} requires the selection of a variable.);

/* Macro variable(s) for UI control with ID of fillGradient */
%let fillGradient=0;

/* Macro variable(s) for UI control with ID of filterString */
%let filterString=;

/* Macro variable(s) for UI control with ID of footnoteSize */
%let footnoteSize=12;

/* Macro variable(s) for UI control with ID of footnoteString */
%let footnoteString=;

/* Macro variable(s) for UI control with ID of footnote_whereFootnote */
%let footnote_whereFootnote=%nrquote(Where clause: {0});

/* Macro variable(s) for UI control with ID of group */
%let group=;
%let group_count=0;

/* Macro variable(s) for UI control with ID of groupDisplay */
%let groupDisplay=cluster;

/* Macro variable(s) for UI control with ID of inchHeight */
%let inchHeight=4.8;

/* Macro variable(s) for UI control with ID of inchWidth */
%let inchWidth=6.4;

/* Macro variable(s) for UI control with ID of includeAsFootnote */
%let includeAsFootnote=0;

/* Macro variable(s) for UI control with ID of legendLoc */
%let legendLoc=outside;

/* Macro variable(s) for UI control with ID of logAxis */
%let logAxis=0;

/* Macro variable(s) for UI control with ID of logBaseCombo */
%let logBaseCombo=10;

/* Macro variable(s) for UI control with ID of logBaseline */
%let logBaseline=;

/* Macro variable(s) for UI control with ID of measure */
%let measure=;
%let measure_count=0;

/* Macro variable(s) for UI control with ID of measureCombo */
%let measureCombo=freq;

/* Macro variable(s) for UI control with ID of pixelHeight */
%let pixelHeight=480;

/* Macro variable(s) for UI control with ID of pixelWidth */
%let pixelWidth=640;

/* Macro variable(s) for UI control with ID of respAxisMax */
%let respAxisMax=0;

/* Macro variable(s) for UI control with ID of respAxisMaxValue */
%let respAxisMaxValue=;

/* Macro variable(s) for UI control with ID of respAxisMin */
%let respAxisMin=0;

/* Macro variable(s) for UI control with ID of respAxisMinValue */
%let respAxisMinValue=;

/* Macro variable(s) for UI control with ID of respLabel */
%let respLabel=;

/* Macro variable(s) for UI control with ID of respLabelRotation */
%let respLabelRotation=0;

/* Macro variable(s) for UI control with ID of respRefCustomLabel */
%let respRefCustomLabel=;

/* Macro variable(s) for UI control with ID of respRefLabel */
%let respRefLabel=respRefValue;

/* Macro variable(s) for UI control with ID of respRefLine */
%let respRefLine=0;

/* Macro variable(s) for UI control with ID of respRefLineValue */
%let respRefLineValue=;

/* Macro variable(s) for UI control with ID of respTickRotate */
%let respTickRotate=respDiagonalRotation;

/* Macro variable(s) for UI control with ID of showRespGrid */
%let showRespGrid=1;

/* Macro variable(s) for UI control with ID of sortByData */
%let sortByData=0;

/* Macro variable(s) for UI control with ID of statChoiceResponse */
%let statChoiceResponse=sum;

/* Macro variable(s) for UI control with ID of titleSize */
%let titleSize=14;

/* Macro variable(s) for UI control with ID of titleString */
%let titleString=;

/* Macro variable(s) for UI control with ID of urlVar */
%let urlVar=;
%let urlVar_count=0;

/* Macro variable(s) for UI control with ID of useColor */
%let useColor=0;

/* Macro variable(s) for UI control with ID of weight */
%let weight=;
%let weight_count=0;

/* Macro variables derived from user input to this step - END */

/* endregion */
/* SAS code provided in template section of Custom Step - BEGIN */
/* ************************************************************************* */
/* Bar Chart provides equivalent functionality as the CTM Bar Chart task.

   Release cadence: 2024.04
*/

/* ************************************************************************* */
/* Inserts values into a localized  message string at the locations
   indicated by tokens of the form `{0}` through `{9}`.
*/
%macro __tranmsg(msg  /* message text with keys {0} - {9} as needed */, value0 /* value for {0} */,
                     value1 /* value for {1} */, value2 /* value for {2} */, value3 /* value for {3} */,
                     value4 /* value for {4} */, value5 /* value for {5} */, value6 /* value for {6} */,
                     value7 /* value for {7} */, value8 /* value for {8} */, value9 /* value for {9} */);
    %local _retVal _i;
    %let _retVal = %superq(msg);
    %let _i = 0;
    %do %while (&_i <= 9 AND %index(%superq(msg), {&_i}) NE 0);
        %let _retval = %qsysfunc(tranwrd(&_retval, {&_i}, %superq(value&_i)));
        %let _i = %eval(&_i + 1);
    %end;
    %superq(_retVal)
%mend __tranmsg;

/* ************************************************************************* */
/* Wraps the supplied label value in single quotes after attempting to
   remove any trailing colon as well as any text enclosed within
   parentheses at the end of the string.
*/
%macro __formatLabel(label);
    %local _reversed _lastChar _firstParen _retVal;
    %let _retVal = ;
    %if %length(&label) NE 0 %then %do;
        %let _reversed = %qtrim(%qsysfunc(reverse(%qtrim(&label))));
        /* Look for a trailing colon and remove it if one is found. */
        %let _lastChar = %qsubstr(&_reversed, 1, 1);
        %if &_lastChar = %str(:) %then %do;
            %let _reversed = %qtrim(%qsubstr(&_reversed, 2));
        %end;
        /* Now check to see if there is text within parentheses at
           the end of the label's string. If found, remove the
           parentheses and all text enclosed. */
        %let _retVal = %qtrim(%qsysfunc(reverse(&_reversed)));
        %let _lastChar = %qsubstr(&_retVal, %length(&_retVal), 1);
        %let _firstParen = %index(&_retVal, %str(%());
        %if &_lastChar = %str(%)) AND &_firstParen > 0 %then %do;
            %let _retVal = %qtrim(%qsubstr(&_retVal, 1, &_firstParen - 1));
        %end;
    %end;
    %str(%'%superq(_retVal)%')
%mend __formatLabel;

/* ************************************************************************* */
/* The locally defined __code() macro writes the generated SAS code inline
   for execution. If an externally defined macro of that name exists, then
   we don't need to create the local version.
*/
%let __locallyDefinedCodeMacro = 0;
%if %sysmacexist(__code) = 0 %then %do;
    %let __locallyDefinedCodeMacro = 1;
    %macro __code(sasCode);
        %unquote(&sasCode);
    %mend;
%end;

/* ************************************************************************* */
/* The locally defined __processErrors() macro writes all error messages to
   the log and then aborts the processing. If an externally defined macro
   of that name exists, then we don't need to create the local version.
*/
%let __locallyDefinedProcErrsMacro = 0;
%if %sysmacexist(__processErrors) = 0 %then %do;
    %let __locallyDefinedProcErrsMacro = 1;
    %macro __processErrors(errorSummaryMsg);
        %local errorMacVar;
        %put ERROR: %sysfunc(tranwrd(&errorSummaryMsg, {0}, &__errorMsg_count));
        %do _errorMsg_index = 1 %to &__errorMsg_count;
            %let errorMacVar = __errorMsg_&_errorMsg_index;
            %put &&&errorMacVar;
            %symdel &errorMacVar;
        %end;
        %symdel __errorMsg_count;
        %abort;
    %mend;
%end;

/* ************************************************************************* */
/* Performs the validation checks. And adds the supplied message to the
    errors 'array' if the test value is true.
*/
%macro __runtimeValidation(test, msg);
%if &test %then %do;
    %let __errorMsg_count = %eval(&__errorMsg_count + 1);
    %global __errorMsg_&__errorMsg_count;
    %let __errorMsg_&__errorMsg_count = %str(ERROR: &msg);
%end;
%mend;

/* ************************************************************************* */
/* Get the first value from a list, if the list is not empty. */
%macro firstValue(listName);
    %if &&&listName._count > 0 %then %do;
        &&&listName._1_name
    %end;
%mend firstValue;

/* ************************************************************************* */
/* runStep() generates a proc sgplot to graph the input data */
%macro runStep();
    /* Globally defined so that the __processErrors macro can get
       access to it. */
    %global
        __errorMsg_count;
    /* Locally scoped macro variables so that we don't interfere with
       similarly named variables defined outside of this macro. */
    %local
        _errorMsg_index
        _cat
        _resp
        _grp
        _url
        _by
        _wgt
        _w
        _h
        _width
        _height
        _sgplot
        _compressFilterString
        _qTitleString
        _qFootnoteString
        _pt
        _titleSizePt
        _footSizePt
        _setAttrs
        _barChartSetts
        _catAxis
        _catAxisSetts
        _respAxis
        _respAxisSetts
        _catRefSetts
        _respRefSetts;

    /* ---------------- */
    /* -- Validation -- */

    %let __errorMsg_count = 0;

    /* Category must have a single variable selected */
    %__runtimeValidation(
        %eval(&category_count = 0),
        %__tranmsg(&error_variableRequired, %__formatLabel(&errorLabel_category))
    )

    /* Measure variable must have a single variable selected */
    %__runtimeValidation(
        %eval(&measureCombo = measureChoiceVar AND &measure_count = 0),
        %__tranmsg(&error_variableRequired, %__formatLabel(&errorLabel_measure))
    )

    /* Maximum measure axis value should be greater than the minimum measure axis value */
    %__runtimeValidation(%sysevalf(&respAxisMin = 1 AND &respAxisMax = 1 AND &respAxisMinValue > &respAxisMaxValue), &error_invalidMeasureAxis)

    /*--Graph Size--*/
    %__runtimeValidation(%sysevalf(&dimType = in AND (&inchWidth < 2 OR &inchWidth > 12)), &error_inchWidthInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = in AND (&inchHeight < 2 OR &inchHeight > 12)), &error_inchHeightInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = cm AND (&cmWidth < 5 OR &cmWidth > 30)), &error_cmWidthInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = cm AND (&cmHeight < 5 OR &cmHeight > 30)), &error_cmHeightInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = px AND (&pixelWidth < 200 OR &pixelWidth > 1200)), &error_pixelWidthInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = px AND (&pixelHeight < 200 OR &pixelHeight > 1200)), &error_pixelHeightInvalidRange)

    /* If we have accumulated any error messages, handle them now and
       stop generating any step code. */
    %if &__errorMsg_count > 0 %then %do;
        /* Insert the localised step name into the generic message and change {1} to {0}
           within the string. */
        %__processErrors(%__tranmsg(&error_errorsInStep, &errorLabel_stepName, {0}))
        %return; /* This %RETURN statement is necessary - do not remove it. */
    %end;

    /* --------------------- */
    /* -- Code Generation -- */

    /* Extract first item from list */
    %let _cat = %firstValue(category);
    %let _resp = ;
    %if &measureCombo = measureChoiceVar %then %do;
        %let _resp = %firstValue(measure);
    %end;
    %let _grp = %firstValue(group);
    %let _url = %firstValue(urlVar);
    %let _by = %firstValue(byVar);
    %let _wgt = %firstValue(weight);

    /* Set Graph Size */
    %let _w = ;
    %let _h = ;
    %if &dimType = in %then %do;
        %let _w = &inchWidth;
        %let _h = &inchHeight;
    %end;
    %else %if &dimType = cm %then %do;
        %let _w = &cmWidth;
        %let _h = &cmHeight;
    %end;
    %else %do;
        %let _w = &pixelWidth;
        %let _h = &pixelHeight;
    %end;
    %let _width = &_w.&dimType;
    %let _height = &_h.&dimType;

    /* Set output size */
    %__code(ods graphics / reset width=&_width height=&_height imagemap)

    %if %length(&_by) > 0 %then %do;
        /* Sort data by BY variable */
        %__code(proc sort data=&dataSource out=_BarChartTaskData)
        %__code(by &_by)
        %__code(run)
    %end;

    /* SGPLOT proc statement */
    %let _sgplot = ;
    %if %length(&_by) > 0 %then %do;
        %let _sgplot = &_sgplot proc sgplot data=_BarChartTaskData;
    %end;
    %else %do;
        %let _sgplot = &_sgplot proc sgplot data=&dataSource;
    %end;
    %let _compressFilterString = %sysfunc(compress(%bquote(&filterString)));
    %if %length(&_compressFilterString) > 0 %then %do;
        %let _sgplot = &_sgplot (where=(%unquote(&filterString)));
    %end;
    %__code(&_sgplot)
    %if %length(&_by) > 0 %then %do;
        /* BY Variable */
        %__code(by &_by)
    %end;

    /* Build quoted strings for title and footnote to clean up any quotes provided by user */
    %if %length(&titleString) > 0 %then %do;
        %let _qTitleString = %sysfunc(quote(&titleString));
    %end;
    %if %length(&footnoteString) > 0 %then %do;
        %let _qFootnoteString = %sysfunc(quote(&footnoteString));
    %end;

    /* TITLE and FOOTNOTE */
    %let _pt = pt;
    %if %length(&titleString) > 0 %then %do;
        %let _titleSizePt = &titleSize&_pt;
        %__code(title height=&_titleSizePt &_qTitleString)
    %end;
    %if ((%length(&footnoteString) > 0) OR (%length(&filterString) > 0 AND &includeAsFootnote = 1)) %then %do;
        %let _footSizePt = &footnoteSize&_pt;
        %if %length(&filterString) > 0 AND &includeAsFootnote = 1 %then %do;
            %__code(footnote justify=left height=&_footSizePt %qsysfunc(quote(%qsysfunc(tranwrd(&footnote_whereFootnote, {0}, &filterString)))))
        %end;
        %if %length(&footnoteString) > 0 %then %do;
            %__code(footnote2 justify=left height=&_footSizePt &_qFootnoteString)
        %end;
    %end;
    %if (&useColor AND &useColor = 1 ) OR &barTrans ~= 0 %then %do;
        %let _setAttrs = Yes;
    %end;
    %else %do;
        %let _setAttrs = No;
    %end;

    /* General Bar Chart Settings */
    %let _barChartSetts = ;
    %if &barOrient = vertical %then %do;
        %let _barChartSetts = &_barChartSetts vbar &_cat /;
    %end;
    %else %do;
        %let _barChartSetts = &_barChartSetts hbar &_cat /;
    %end;
    %if %length(&_resp) > 0 %then %do;
        %let _barChartSetts = &_barChartSetts response=&_resp;
    %end;
    %if %length(&_url) > 0 %then %do;
        %let _barChartSetts = &_barChartSetts url=&_url;
    %end;
    %if %length(&_grp) > 0 %then %do;
        %let _barChartSetts = &_barChartSetts group=&_grp groupdisplay=&groupDisplay;
    %end;
    /* Handles color and transparency options for the bar chart */
    %if &_setAttrs = Yes %then %do;
        %if &useColor = 1 AND %length(&_grp) = 0 AND &barTrans ~= 0 %then %do;
            %let _barChartSetts = &_barChartSetts fillattrs=(color=CX&barColor transparency=&bartrans);
        %end;
        %else %if &useColor = 1 AND %length(&_grp) = 0 %then %do;
            %let _barChartSetts = &_barChartSetts fillattrs=(color=CX&barColor);
        %end;
        %else %if &barTrans ~= 0 %then %do;
            %let _barChartSetts = &_barChartSetts fillattrs=(transparency=&barTrans);
        %end;
    %end;
    %if &barStatLabels = 1 %then %do;
        %let _barChartSetts = &_barChartSetts datalabel;
    %end;

    /* Sets the limits of the bar chart with default or custom values */
    %if %length(&barLimits) > 0 %then %do;
        %if &barLimits ~= none %then %do;
            %let _barChartSetts = &_barChartSetts limits=&barLimits limitstat=&barLimitStat;
            %if %length(&barNumStdChkbox) > 0 AND &barNumStdChkbox = 1 %then %do;
                %let _barChartSetts = &_barChartSetts numstd=&barNumStd;
            %end;
            %if &barLimitStat = clm %then %do;
                /* Calculate alpha from confidence level */
                %if &confLevelCombo = confLevel99Choice %then %do;
                    %let _barChartSetts = &_barChartSetts alpha=0.01;
                %end;
                %else %if &confLevelCombo = confLevel90Choice %then %do;
                    %let _barChartSetts = &_barChartSetts alpha=0.10;
                %end;
                %else %if &confLevelCombo = confLevelCustomChoice %then %do;
                    %if &confLevel ~= 95 %then %do;
                        %let _barChartSetts = &_barChartSetts alpha=%sysfunc(abs((100-&confLevel)/100));
                    %end;
                %end;
            %end;
        %end;
        %if &fillGradient = 1 %then %do;
            %let _barChartSetts = &_barChartSetts fillType=gradient;
        %end;
        %if %length(&_resp) > 0 %then %do;
            %if &statChoiceResponse ~= sum %then %do;
                %let _barChartSetts = &_barChartSetts stat=&statChoiceResponse;
            %end;
        %end;
        %else %do;
            %if &measureCombo ~= freq %then %do;
                %let _barChartSetts = &_barChartSetts stat=&measureCombo;
            %end;
        %end;
        %if &barSkin ~= none %then %do;
            %let _barChartSetts = &_barChartSetts dataskin=&barSkin;
        %end;
        %if %length(&_resp) > 0 %then %do;
            %if &displayRespLabel1 = statsLabel %then %do;
                %let _barChartSetts = &_barChartSetts statlabel;
            %end;
            %else %if &displayRespLabel1 = noStatsLabel %then %do;
               %let _barChartSetts = &_barChartSetts nostatlabel;
            %end;
        %end;
        %if &logAxis = 1 %then %do;
            %let _barChartSetts = &_barChartSetts baseline=&logBaseline;
        %end;
        %if %length(&_wgt) > 0 %then %do;
            %let _barChartSetts = &_barChartSetts weight=&_wgt;
        %end;
        %__code(&_barChartSetts)

        /* Enabling category axis settings if one or more has been selected */
        %let _catAxis = 0;
        %if &displayCatLabel ~= defaultLabel OR &sortByData = 1 OR &catReverse = 1 OR &catLabelRotation = 1 %then %do;
            %let _catAxis = 1;
        %end;

        /* Options for data order and reference line inclusion on category axis */
        %if &_catAxis = 1 %then %do;
            %let _catAxisSetts = ;
            %if &barOrient = vertical %then %do;
                %let _catAxisSetts = &_catAxisSetts xaxis;
            %end;
            %else %do;
                %let _catAxisSetts = &_catAxisSetts yaxis;
            %end;
            %if &sortByData = 1 %then %do;
                %let _catAxisSetts = &_catAxisSetts discreteorder=data;
            %end;
            %if &catReverse = 1 %then %do;
                %let _catAxisSetts = &_catAxisSetts reverse;
            %end;
            %if &displayCatLabel = noLabel %then %do;
                %let _catAxisSetts = &_catAxisSetts display=(nolabel);
            %end;
            %if &displayCatLabel = customLabel %then %do;
                %let _catAxisSetts = &_catAxisSetts label=%sysfunc(quote(&catLabel));
            %end;
            %if &catLabelRotation = 1 %then %do;
                %if &catTickRotate = catDiagonalRotation %then %do;
                    %let _catAxisSetts = &_catAxisSetts valuesrotate=diagonal;
                %end;
                %else %do;
                    %let _catAxisSetts = &_catAxisSetts valuesrotate=vertical;
                %end;
            %end;
            %__code(&_catAxisSetts)
        %end;

        /* Enabling response axis settings if one or more has been selected */
        %let _respAxis = 0;
        %if (&measureCombo = measureChoiceVar AND &measure_count > 0 AND (&displayRespLabel1 = noLabel OR &displayRespLabel1 = customLabel))
            OR (&measureCombo ~= measureChoiceVar AND (&displayRespLabel2 = noLabel OR &displayRespLabel2 = customLabel))
            OR &showRespGrid = 1 OR &logAxis = 1 OR &respLabelRotation = 1 OR &respAxisMin = 1 OR &respAxisMax = 1 %then %do;
            %let _respAxis = 1;
        %end;

        /* Handling options for response axis if chosen */
        %if &_respAxis = 1 %then %do;
            %let _respAxisSetts = ;
            %if &barOrient = vertical %then %do;
                %let _respAxisSetts = &_respAxisSetts yaxis;
            %end;
            %else %do;
                %let _respAxisSetts = &_respAxisSetts xaxis;
            %end;
            %if &respAxisMin = 1 %then %do;
                %let _respAxisSetts = &_respAxisSetts min=&respAxisMinValue;
            %end;
            %if &respAxisMax = 1 %then %do;
                %let _respAxisSetts = &_respAxisSetts max=&respAxisMaxValue;
            %end;
            %if &showRespGrid = 1 %then %do;
                %let _respAxisSetts = &_respAxisSetts grid;
            %end;
            /* Checks for whether custom label or no label have been selected */
            %if (&measureCombo = measureChoiceVar AND &measure_count > 0 AND &displayRespLabel1 = noLabel) OR (&measureCombo ~= measureChoiceVar AND &displayRespLabel2 = noLabel) %then %do;
                %let _respAxisSetts = &_respAxisSetts (display=(nolabel));
            %end;
            %if (&measureCombo = measureChoiceVar AND &measure_count > 0 AND &displayRespLabel1 = customLabel) OR (&measureCombo ~= measureChoiceVar AND &displayRespLabel2 = customLabel) %then %do;
               %let _respAxisSetts = &_respAxisSetts label=%sysfunc(quote(&respLabel));
            %end;
            /* Enables logarithmic scale and the base value to use */
            %if &logAxis = 1 %then %do;
                %let _respAxisSetts = &_respAxisSetts type=log;
                %if &logBaseCombo ~= 10 %then %do;
                    %let _respAxisSetts = &_respAxisSetts logbase=&logBaseCombo;
                %end;
            %end;
            %if &respLabelRotation = 1 AND &barOrient = horizontal %then %do;
                %if &respTickRotate = respDiagonalRotation %then %do;
                    %let _respAxisSetts = &_respAxisSetts valuesrotate=diagonal;
                %end;
                %else %do;
                    %let _respAxisSetts = &_respAxisSetts valuesrotate=vertical;
                %end;
            %end;
            %__code(&_respAxisSetts)
        %end;

        /* Individual settings for category reference line */
        %if &catRefLine = 1 %then %do;
            %let _catRefSetts = refline;
            %if %qupcase(&category_1_type) = CHARACTER %then %do;
                /* Apply any associated character format to the raw ref line value. */
                %if &category_1_format NE %then %do;
                    %let catRefLineValue = %qsysfunc(putc(&catRefLineValue, &category_1_format));
                %end;
                %let _catRefSetts = &_catRefSetts %qsysfunc(quote(&catRefLineValue));
            %end;
            %else %do;
                /* Apply any associated numeric format to the raw ref line value. */
                %if &category_1_format NE %then %do;
                    %let catRefLineValue = %qsysfunc(quote(%qleft(%qsysfunc(putn(&catRefLineValue, &category_1_format)))));
                %end;
                %let _catRefSetts = &_catRefSetts &catRefLineValue;
            %end;
            %let _catRefSetts = &_catRefSetts /;
            %if &barOrient = vertical %then %do;
                %let _catRefSetts = &_catRefSetts axis=x;
            %end;
            %else %do;
                %let _catRefSetts = &_catRefSetts axis=y;
            %end;
            %let _catRefSetts = &_catRefSetts lineattrs=(thickness=2 color=blue);
            %if %sysevalf(&catRefLineOffset ~= 0) %then %do;
                %let _catRefSetts = &_catRefSetts discreteoffset=&catRefLineOffset;
            %end;
            %if &catRefLabel = catRefCustom %then %do;
                %let _catRefSetts = &_catRefSetts label=%sysfunc(quote(&catRefCustomLabel));
            %end;
            %else %do;
                %let _catRefSetts = &_catRefSetts label;
            %end;
            %let _catRefSetts = &_catRefSetts labelattrs=(color=blue);
            %__code(&_catRefSetts)
        %end;

        /* Individual settings for response reference line */
        %if &respRefLine = 1 %then %do;
            %let _respRefSetts = refline &respRefLineValue /;
            %if &barOrient = vertical %then %do;
                %let _respRefSetts = &_respRefSetts axis=y;
            %end;
            %else %do;
                %let _respRefSetts = &_respRefSetts axis=x;
            %end;
            %let _respRefSetts = &_respRefSetts lineattrs=(thickness=2 color=green);
            %if &respRefLabel = respRefCustom %then %do;
                %let _respRefSetts = &_respRefSetts label=%sysfunc(quote(&respRefCustomLabel));
            %end;
            %else %do;
                %let _respRefSetts = &_respRefSetts label;
            %end;
            %let _respRefSetts = &_respRefSetts labelattrs=(color=green);
            %__code(&_respRefSetts)
        %end;

        %if %length(&_grp) > 0 AND &legendLoc = inside %then %do;
            /* Legend Settings */
            %__code(keylegend / location=&legendLoc)
        %end;
        %__code(run)

        /* Clean up */
        %__code(ods graphics / reset)
        %if %length(&titleString) > 0 %then %do;
            %__code(title)
        %end;
        %if %length(&footnoteString) > 0 OR (%length(&filterString) > 0 AND &includeAsFootnote = 1) %then %do;
            %if %length(&filterString) > 0 AND &includeAsFootnote = 1 %then %do;
                %__code(footnote)
            %end;
            %if %length(&footnoteString) > 0 %then %do;
                %__code(footnote2)
            %end;
        %end;
        %if %length(&_by) > 0 %then %do;
            %__code(proc datasets library=WORK noprint)
            %__code(delete _BarChartTaskData)
            %__code(run)
        %end;
    %end;

%mend runStep;


/* ************************************************************************* */
/* Main entry point: All the work is done in the macro. */
%let __locallyDefinedEntryPointMacro = 0;
%if %sysmacexist(__entryPoint) = 0 %then %do;
    %let __locallyDefinedEntryPointMacro = 1;
    %macro __entryPoint();
        %runStep()
    %mend __entryPoint;
  %end;

options mprint;
%__entryPoint()

/* ************************************************************************* */
/* Tidy up macros and macro variables that have been defined. */
%sysmacdelete __formatLabel;
%sysmacdelete __tranmsg;

/* If we created a local __entryPoint macro, remove it. */
%if &__locallyDefinedEntryPointMacro = 1 %then %do;
    %sysmacdelete __entryPoint;
%end;
%symdel __locallyDefinedEntryPointMacro;

/* If we created a local __processErrors macro, remove it. */
%if &__locallyDefinedProcErrsMacro = 1 %then %do;
    %sysmacdelete __processErrors;
%end;
%symdel __locallyDefinedProcErrsMacro;

/* If we created a local __code macro, remove it. */
%if &__locallyDefinedCodeMacro = 1 %then %do;
    %sysmacdelete __code;
%end;
%symdel __locallyDefinedCodeMacro;

/* SAS code provided in template section of Custom Step - END */

/* region: Generated macro cleanup */

/* Cleanup macros and macro variables - BEGIN */
/* Delete macro variables created in this step */

%_flw_del_macro_vars( barColor );
%_flw_del_macro_vars( barLimitStat );
%_flw_del_macro_vars( barLimits );
%_flw_del_macro_vars( barNumStd );
%_flw_del_macro_vars( barNumStdChkbox );
%_flw_del_macro_vars( barOrient );
%_flw_del_macro_vars( barSkin );
%_flw_del_macro_vars( barStatLabels );
%_flw_del_macro_vars( barTrans );
%_flw_del_macro_vars( byVar byVar_count );
%_flw_del_macro_vars( catLabel );
%_flw_del_macro_vars( catLabelRotation );
%_flw_del_macro_vars( catRefCustomLabel );
%_flw_del_macro_vars( catRefLabel );
%_flw_del_macro_vars( catRefLine );
%_flw_del_macro_vars( catRefLineOffset );
%_flw_del_macro_vars( catRefLineValue );
%_flw_del_macro_vars( catReverse );
%_flw_del_macro_vars( catTickRotate );
%_flw_del_macro_vars( category category_count category_1_format category_1_informat category_1_label category_1_name
                  category_1_name_base category_1_rawlength category_1_type );
%_flw_del_macro_vars( cmHeight );
%_flw_del_macro_vars( cmWidth );
%_flw_del_macro_vars( confLevel );
%_flw_del_macro_vars( confLevelCombo );
%_flw_del_macro_vars( dataSource dataSource_engine dataSource_label dataSource_lib dataSource_name dataSource_name_base
                  dataSource_type );
%_flw_del_macro_vars( dimType );
%_flw_del_macro_vars( displayCatLabel );
%_flw_del_macro_vars( displayRespLabel1 );
%_flw_del_macro_vars( displayRespLabel2 );
%_flw_del_macro_vars( errorLabel_category );
%_flw_del_macro_vars( errorLabel_measure );
%_flw_del_macro_vars( errorLabel_stepName );
%_flw_del_macro_vars( error_cmHeightInvalidRange );
%_flw_del_macro_vars( error_cmWidthInvalidRange );
%_flw_del_macro_vars( error_errorsInStep );
%_flw_del_macro_vars( error_inchHeightInvalidRange );
%_flw_del_macro_vars( error_inchWidthInvalidRange );
%_flw_del_macro_vars( error_invalidMeasureAxis );
%_flw_del_macro_vars( error_pixelHeightInvalidRange );
%_flw_del_macro_vars( error_pixelWidthInvalidRange );
%_flw_del_macro_vars( error_variableRequired );
%_flw_del_macro_vars( fillGradient );
%_flw_del_macro_vars( filterString );
%_flw_del_macro_vars( footnoteSize );
%_flw_del_macro_vars( footnoteString );
%_flw_del_macro_vars( footnote_whereFootnote );
%_flw_del_macro_vars( group group_count );
%_flw_del_macro_vars( groupDisplay );
%_flw_del_macro_vars( inchHeight );
%_flw_del_macro_vars( inchWidth );
%_flw_del_macro_vars( includeAsFootnote );
%_flw_del_macro_vars( legendLoc );
%_flw_del_macro_vars( logAxis );
%_flw_del_macro_vars( logBaseCombo );
%_flw_del_macro_vars( logBaseline );
%_flw_del_macro_vars( measure measure_count );
%_flw_del_macro_vars( measureCombo );
%_flw_del_macro_vars( pixelHeight );
%_flw_del_macro_vars( pixelWidth );
%_flw_del_macro_vars( respAxisMax );
%_flw_del_macro_vars( respAxisMaxValue );
%_flw_del_macro_vars( respAxisMin );
%_flw_del_macro_vars( respAxisMinValue );
%_flw_del_macro_vars( respLabel );
%_flw_del_macro_vars( respLabelRotation );
%_flw_del_macro_vars( respRefCustomLabel );
%_flw_del_macro_vars( respRefLabel );
%_flw_del_macro_vars( respRefLine );
%_flw_del_macro_vars( respRefLineValue );
%_flw_del_macro_vars( respTickRotate );
%_flw_del_macro_vars( showRespGrid );
%_flw_del_macro_vars( sortByData );
%_flw_del_macro_vars( statChoiceResponse );
%_flw_del_macro_vars( titleSize );
%_flw_del_macro_vars( titleString );
%_flw_del_macro_vars( urlVar urlVar_count );
%_flw_del_macro_vars( useColor );
%_flw_del_macro_vars( weight weight_count );
/* Delete macros defined in this step */
%_flw_del_macros(_flw_get_column_list _flw_del_macro_vars);

/* Cleanup macros and macro variables - END */

%sysmacdelete _flw_del_macros;

/* endregion */


/* region: Generated step cleanup for Bar Chart */
%_flw_action_end(id-1750923014674-2862, , , );
/* endregion */

/*===========================================================================*
* Node name:        Histogram
* Node ID:          id-1751183183329-38307
*
* Input Tables:
*   WORK.Final
*
* Step name:        Histogram
* Step path:        /dataFlows/steps/0a206602-728f-4d76-a222-6deb279f9cdf
* Step description: Histogram step creates a frequency distribution of a numeric variable.
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1751183183329-38307);
/* endregion */

/* region: Generated macro initialization */

/* Define utility macros - BEGIN */

/* Macro to get a list of column names */
%macro _flw_get_column_list(_flw_prefix = %nrstr(), _delim=%str( ));
   %do _flw_index=1 %to %unquote(&&&_flw_prefix._count);%unquote(&&&_flw_prefix._&_flw_index._name)%if &_flw_index.<%unquote(&&&_flw_prefix._count)%then&_delim.; %end;
%mend;

/* Macro to delete macro variables with names passed in */
%macro _flw_del_macro_vars(_flw_macro_vars_to_delete,_flw_no_warn=Y);
   %if "&_flw_no_warn"="Y" %then %symdel &_flw_macro_vars_to_delete/NOWARN;
   %else %symdel &_flw_macro_vars_to_delete;
%mend;

/* Macro to delete a list of macros with names passed in */
%macro _flw_del_macros(_flw_macro_names,_flw_no_warn=Y);
   %let num=1;
   %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %do %while (&_flw_local_macros_to_delete ne );
      %if "&_flw_no_warn"="Y" %then %sysmacdelete &_flw_local_macros_to_delete/NOWARN;
      %else %sysmacdelete &_flw_local_macros_to_delete;
      %let num=%eval(&num+1);
      %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %end;
%mend;

/* Define utility macros - END */

/* Macro variables derived from user input to this step - BEGIN */

/* Macro variable(s) for UI control with ID of applyColorGradient */
%let applyColorGradient=0;

/* Macro variable(s) for UI control with ID of binColor */
%let binColor=CAD5E5;

/* Macro variable(s) for UI control with ID of byVar */
%let byVar=;
%let byVar_count=0;

/* Macro variable(s) for UI control with ID of cmHeight */
%let cmHeight=12;

/* Macro variable(s) for UI control with ID of cmWidth */
%let cmWidth=16;

/* Macro variable(s) for UI control with ID of colorGradient */
%let colorGradient=none;

/* Macro variable(s) for UI control with ID of colorTransparency */
%let colorTransparency=0;

/* Macro variable(s) for UI control with ID of dataSource */
%let dataSource=WORK.Final;
%let dataSource_engine=V9;
%let dataSource_label=;
%let dataSource_lib=WORK;
%let dataSource_name=Final;
%let dataSource_name_base=Final;
%let dataSource_type=;

/* Macro variable(s) for UI control with ID of dataSource_WhereClause */
%let dataSource_WhereClause=;

/* Macro variable(s) for UI control with ID of displayXLabel */
%let displayXLabel=defaultLabel;

/* Macro variable(s) for UI control with ID of displayYLabel */
%let displayYLabel=defaultLabel;

/* Macro variable(s) for UI control with ID of errorLabel_analysisVariable */
%let errorLabel_analysisVariable=%nrquote(Analysis variable:);

/* Macro variable(s) for UI control with ID of errorLabel_fontSize */
%let errorLabel_fontSize=%nrquote(Font size %(default: 14 pt%):);

/* Macro variable(s) for UI control with ID of errorLabel_footnote */
%let errorLabel_footnote=Footnote:;

/* Macro variable(s) for UI control with ID of errorLabel_inputData */
%let errorLabel_inputData=%nrquote(Input data:);

/* Macro variable(s) for UI control with ID of errorLabel_label */
%let errorLabel_label=Label:;

/* Macro variable(s) for UI control with ID of errorLabel_maximumValue */
%let errorLabel_maximumValue=%nrquote(Maximum value:);

/* Macro variable(s) for UI control with ID of errorLabel_minimumValue */
%let errorLabel_minimumValue=%nrquote(Minimum value:);

/* Macro variable(s) for UI control with ID of errorLabel_numberOfBins */
%let errorLabel_numberOfBins=%nrquote(Number of bins:);

/* Macro variable(s) for UI control with ID of errorLabel_stepName */
%let errorLabel_stepName=Histogram;

/* Macro variable(s) for UI control with ID of errorLabel_title */
%let errorLabel_title=Title:;

/* Macro variable(s) for UI control with ID of errorLabel_xAxis */
%let errorLabel_xAxis=%nrquote(X Axis);

/* Macro variable(s) for UI control with ID of errorLabel_yAxis */
%let errorLabel_yAxis=%nrquote(Y Axis);

/* Macro variable(s) for UI control with ID of error_cmHeightInvalidRange */
%let error_cmHeightInvalidRange=%nrquote(%'Graph size height%' requires a number greater than or equal to 5 and less than or equal to 30 for the height in centimeters.);

/* Macro variable(s) for UI control with ID of error_cmWidthInvalidRange */
%let error_cmWidthInvalidRange=%nrquote(%'Graph size width%' requires a number greater than or equal to 5 and less than or equal to 30 for the width in centimeters.);

/* Macro variable(s) for UI control with ID of error_errorsInStep */
%let error_errorsInStep=%nrquote(The {0} step contained the following {1} errors and could not be run:);

/* Macro variable(s) for UI control with ID of error_genericIntInRange */
%let error_genericIntInRange=%nrquote({0} requires an integer greater than or equal to {1} and less than or equal to {2}.);

/* Macro variable(s) for UI control with ID of error_genericIntInRange2 */
%let error_genericIntInRange2=%nrquote(The {0} property for {1} requires an integer greater than or equal to {2} and less than or equal to {3}.);

/* Macro variable(s) for UI control with ID of error_genericTableInfoIncomplete */
%let error_genericTableInfoIncomplete=%nrquote(The {0} table information is incomplete. Either the %'Library%' or %'Table name%' is empty.);

/* Macro variable(s) for UI control with ID of error_genericValueRequired */
%let error_genericValueRequired=%nrquote(A value is required for {0}.);

/* Macro variable(s) for UI control with ID of error_genericValueRequired2 */
%let error_genericValueRequired2=%nrquote(A value is required for the {0} property in {1}.);

/* Macro variable(s) for UI control with ID of error_genericVarRequired */
%let error_genericVarRequired=%nrquote({0} requires the selection of a variable.);

/* Macro variable(s) for UI control with ID of error_inchHeightInvalidRange */
%let error_inchHeightInvalidRange=%nrquote(%'Graph size height%' requires a number greater than or equal to 2 and less than or equal to 12 for the height in inches.);

/* Macro variable(s) for UI control with ID of error_inchWidthInvalidRange */
%let error_inchWidthInvalidRange=%nrquote(%'Graph size width%' requires a number greater than or equal to 2 and less than or equal to 12 for the width in inches.);

/* Macro variable(s) for UI control with ID of error_pixelHeightInvalidRange */
%let error_pixelHeightInvalidRange=%nrquote(%'Graph size height%' requires an integer greater than or equal to 200 and less than or equal to 1200 for the height in pixels.);

/* Macro variable(s) for UI control with ID of error_pixelWidthInvalidRange */
%let error_pixelWidthInvalidRange=%nrquote(%'Graph size width%' requires an integer greater than or equal to 200 and less than or equal to 1200 for the width in pixels.);

/* Macro variable(s) for UI control with ID of error_xAxisMaxLtMin */
%let error_xAxisMaxLtMin=%nrquote(The maximum value of the %'X Axis%' should be greater than or equal to the minimum value of the %'X Axis%'.);

/* Macro variable(s) for UI control with ID of error_xRefLabelRequired */
%let error_xRefLabelRequired=%nrquote(A value is required for %'X Axis reference value as label%'.);

/* Macro variable(s) for UI control with ID of error_xRefValueRequired */
%let error_xRefValueRequired=%nrquote(A value is required for x axis %'Reference value%'.);

/* Macro variable(s) for UI control with ID of error_yAxisMaxLtMin */
%let error_yAxisMaxLtMin=%nrquote(The maximum value of the %'Y Axis%' should be greater than or equal to the minimum value of the %'Y Axis%'.);

/* Macro variable(s) for UI control with ID of error_yRefLabelRequired */
%let error_yRefLabelRequired=%nrquote(A value is required for %'Y Axis reference value as label%'.);

/* Macro variable(s) for UI control with ID of error_yRefValueRequired */
%let error_yRefValueRequired=%nrquote(A value is required for y axis %'Reference value%'.);

/* Macro variable(s) for UI control with ID of footnoteSize */
%let footnoteSize=12;

/* Macro variable(s) for UI control with ID of footnoteString */
%let footnoteString=;

/* Macro variable(s) for UI control with ID of footnote_whereFootnote */
%let footnote_whereFootnote=%nrquote(Where clause: {0});

/* Macro variable(s) for UI control with ID of graphUnits */
%let graphUnits=%nrquote(in);

/* Macro variable(s) for UI control with ID of inchHeight */
%let inchHeight=4.8;

/* Macro variable(s) for UI control with ID of inchWidth */
%let inchWidth=6.4;

/* Macro variable(s) for UI control with ID of includeAsFootnote */
%let includeAsFootnote=0;

/* Macro variable(s) for UI control with ID of kernelDensity */
%let kernelDensity=0;

/* Macro variable(s) for UI control with ID of legendLocation */
%let legendLocation=outside;

/* Macro variable(s) for UI control with ID of normalDensity */
%let normalDensity=0;

/* Macro variable(s) for UI control with ID of numBins */
%let numBins=5;

/* Macro variable(s) for UI control with ID of pixelHeight */
%let pixelHeight=480;

/* Macro variable(s) for UI control with ID of pixelWidth */
%let pixelWidth=640;

/* Macro variable(s) for UI control with ID of response */
%let response=interest_rate_clean;
%let response_count=1;

/* Macro variables for column <interest_rate_clean> */
%let response_1_format=;
%let response_1_informat=;
%let response_1_label=;
%let response_1_name=interest_rate_clean;
%let response_1_name_base=interest_rate_clean;
%let response_1_rawlength=8;
%let response_1_type=Numeric;

/* Macro variable(s) for UI control with ID of scale */
%let scale=percent;

/* Macro variable(s) for UI control with ID of setBinColor */
%let setBinColor=0;

/* Macro variable(s) for UI control with ID of setNumBins */
%let setNumBins=0;

/* Macro variable(s) for UI control with ID of setXRefLineValue */
%let setXRefLineValue=0;

/* Macro variable(s) for UI control with ID of setXRotation */
%let setXRotation=0;

/* Macro variable(s) for UI control with ID of setYRefLineValue */
%let setYRefLineValue=0;

/* Macro variable(s) for UI control with ID of showTickMarks */
%let showTickMarks=0;

/* Macro variable(s) for UI control with ID of showXGridLines */
%let showXGridLines=0;

/* Macro variable(s) for UI control with ID of showYGridLines */
%let showYGridLines=1;

/* Macro variable(s) for UI control with ID of titleSize */
%let titleSize=14;

/* Macro variable(s) for UI control with ID of titleString */
%let titleString=;

/* Macro variable(s) for UI control with ID of weight */
%let weight=;
%let weight_count=0;

/* Macro variable(s) for UI control with ID of xAxisMax */
%let xAxisMax=0;

/* Macro variable(s) for UI control with ID of xAxisMaxValue */
%let xAxisMaxValue=;

/* Macro variable(s) for UI control with ID of xAxisMin */
%let xAxisMin=0;

/* Macro variable(s) for UI control with ID of xAxisMinValue */
%let xAxisMinValue=;

/* Macro variable(s) for UI control with ID of xLabel */
%let xLabel=;

/* Macro variable(s) for UI control with ID of xRefCustomLabel */
%let xRefCustomLabel=;

/* Macro variable(s) for UI control with ID of xRefLabelRadio */
%let xRefLabelRadio=xRefValue;

/* Macro variable(s) for UI control with ID of xRefLineValue */
%let xRefLineValue=;

/* Macro variable(s) for UI control with ID of xRotationValue */
%let xRotationValue=diagonal;

/* Macro variable(s) for UI control with ID of yAxisMax */
%let yAxisMax=0;

/* Macro variable(s) for UI control with ID of yAxisMaxValue */
%let yAxisMaxValue=;

/* Macro variable(s) for UI control with ID of yAxisMin */
%let yAxisMin=0;

/* Macro variable(s) for UI control with ID of yAxisMinValue */
%let yAxisMinValue=;

/* Macro variable(s) for UI control with ID of yLabel */
%let yLabel=;

/* Macro variable(s) for UI control with ID of yRefCustomLabel */
%let yRefCustomLabel=;

/* Macro variable(s) for UI control with ID of yRefLabelRadio */
%let yRefLabelRadio=yRefValue;

/* Macro variable(s) for UI control with ID of yRefLineValue */
%let yRefLineValue=;

/* Macro variables derived from user input to this step - END */

/* endregion */
/* SAS code provided in template section of Custom Step - BEGIN */
/* ************************************************************************* */
/* Histogram provides equivalent functionality as the CTM Histogram task.

   Release cadence: 2024.04
*/

/* ************************************************************************* */
/* Inserts values into a localized  message string at the locations
   indicated by tokens of the form `{0}` through `{9}`.
*/
%macro __tranmsg(msg  /* message text with keys {0} - {9} as needed */, value0 /* value for {0} */,
                 value1 /* value for {1} */, value2 /* value for {2} */, value3 /* value for {3} */,
                 value4 /* value for {4} */, value5 /* value for {5} */, value6 /* value for {6} */,
                 value7 /* value for {7} */, value8 /* value for {8} */, value9 /* value for {9} */);
    %local _retVal _i;
    %let _retVal = %superq(msg);
    %let _i = 0;
    %do %while (&_i <= 9 AND %index(%superq(msg), {&_i}) NE 0);
        %let _retval = %qsysfunc(tranwrd(&_retval, {&_i}, %superq(value&_i)));
        %let _i = %eval(&_i + 1);
    %end;
    %superq(_retVal)
%mend __tranmsg;

/* ************************************************************************* */
/* Wraps the supplied label value in single quotes after attempting to
   remove any trailing colon as well as any text enclosed within
   parentheses at the end of the string.
*/
%macro __formatLabel(label);
    %local _reversed _lastChar _firstParen _retVal;
    %let _retVal = ;
    %if %length(&label) NE 0 %then %do;
        %let _reversed = %qtrim(%qsysfunc(reverse(%qtrim(&label))));
        /* Look for a trailing colon and remove it if one is found. */
        %let _lastChar = %qsubstr(&_reversed, 1, 1);
        %if &_lastChar = %str(:) %then %do;
            %let _reversed = %qtrim(%qsubstr(&_reversed, 2));
        %end;
        /* Now check to see if there is text within parentheses at
           the end of the label's string. If found, remove the
           parentheses and all text enclosed. */
        %let _retVal = %qtrim(%qsysfunc(reverse(&_reversed)));
        %let _lastChar = %qsubstr(&_retVal, %length(&_retVal), 1);
        %let _firstParen = %index(&_retVal, %str(%());
        %if &_lastChar = %str(%)) AND &_firstParen > 0 %then %do;
            %let _retVal = %qtrim(%qsubstr(&_retVal, 1, &_firstParen - 1));
        %end;
    %end;
    %str(%'%superq(_retVal)%')
%mend __formatLabel;

/* ************************************************************************* */
/* The locally defined __code() macro writes the generated SAS code inline
   for execution. If an externally defined macro of that name exists, then
   we do not need to create the local version.
*/
%let __locallyDefinedCodeMacro = 0;
%if %sysmacexist(__code) = 0 %then %do;
    %let __locallyDefinedCodeMacro = 1;
    %macro __code(sasCode);
        %unquote(&sasCode);
    %mend;
%end;

/* ************************************************************************* */
/* The locally defined __processErrors() macro writes all error messages to
   the log and then aborts the processing. If an externally defined macro
   of that name exists, then we don't need to create the local version.
*/
%let __locallyDefinedProcErrsMacro = 0;
%if %sysmacexist(__processErrors) = 0 %then %do;
    %let __locallyDefinedProcErrsMacro = 1;
    %macro __processErrors(errorSummaryMsg);
        %local errorMacVar;
        %put ERROR: %sysfunc(tranwrd(&errorSummaryMsg, {0}, &__errorMsg_count));
        %do _errorMsg_index = 1 %to &__errorMsg_count;
            %let errorMacVar = __errorMsg_&_errorMsg_index;
            %put &&&errorMacVar;
            %symdel &errorMacVar;
        %end;
        %symdel __errorMsg_count;
        %abort;
    %mend;
%end;

/* ************************************************************************* */
/* Performs the validation checks. And adds the supplied message to the
   errors 'array' if the test value is true.
*/
%macro __runtimeValidation(test, msg);
    %if &test %then %do;
        %let __errorMsg_count = %eval(&__errorMsg_count + 1);
        %global __errorMsg_&__errorMsg_count;
        %let __errorMsg_&__errorMsg_count = %str(ERROR: &msg);
    %end;
%mend;

/* ************************************************************************* */
/* runStep() creates a frequency distribution of a numeric variable.
*/
%macro runStep();
    /* Globally defined so that the __processErrors macro can get
       access to it. */
    %global
        __errorMsg_count;

    /* Locally scoped macro variables so that we do not interfere with
       similarly named variables defined outside of this macro. */
    %local
        _errorMsg_index
        _dataset
        _width
        _height
        _title
        _footnote
        _histogramStatement
        _setAttrs
        _procStatement
        _xAxisStatement
        _yAxisStatement
        _xRefLineStatement
        _yRefLineStatement
        _filterString
        _filterFootnote;

    /* ---------------- */
    /* -- Validation -- */

    %let __errorMsg_count = 0;

    /* A valid input table must have been selected */
    %__runtimeValidation(
        %eval(&dataSource_lib = OR &dataSource_name = ),
        %__tranmsg(&error_genericTableInfoIncomplete, %__formatLabel(&errorLabel_inputData))
    )

    /* Response variable runtime error */
    %__runtimeValidation(
        %eval(&response_count = 0),
        %__tranmsg(&error_genericVarRequired, %__formatLabel(&errorLabel_analysisVariable))
    )

    /* Bins runtime error */
    %__runtimeValidation(
        %eval(&setNumBins = 1 AND &numBins = ),
        %__tranmsg(&error_genericValueRequired, %__formatLabel(&errorLabel_numberOfBins))
    )
    %__runtimeValidation(
        %eval(&setNumBins = 1 AND (&numBins NE AND (&numBins < 2 OR &numBins > 10000))),
        %__tranmsg(&error_genericIntInRange, %__formatLabel(&errorLabel_numberOfBins), 2, 10000)
    )

    /* X axis runtime errors */
    %__runtimeValidation(
        %sysevalf(&xAxisMin = 1 AND &xAxisMinValue = ),
        %__tranmsg(&error_genericValueRequired2, %__formatLabel(&errorLabel_minimumValue), %__formatLabel(&errorLabel_xAxis))
    )
    %__runtimeValidation(
        %sysevalf(&xAxisMax = 1 AND &xAxisMaxValue = ),
        %__tranmsg(&error_genericValueRequired2, %__formatLabel(&errorLabel_maximumValue), %__formatLabel(&errorLabel_xAxis))
    )
    %__runtimeValidation(
        %sysevalf(&displayXLabel = customLabel AND &xLabel = ),
        %__tranmsg(&error_genericValueRequired2, %__formatLabel(&errorLabel_label), %__formatLabel(&errorLabel_xAxis))
    )
    %__runtimeValidation(
        %sysevalf(&setXRefLineValue = 1 AND &xRefLabelRadio = xRefCustom AND &xRefCustomLabel = ),
        &error_xRefLabelRequired
    )
    %__runtimeValidation(
        %sysevalf(&xAxisMin = 1 AND &xAxisMax = 1 AND &xAxisMinValue > &xAxisMaxValue),
        &error_xAxisMaxLtMin
    )
    %__runtimeValidation(%sysevalf(&setXRefLineValue = 1 AND &xRefLineValue = ), &error_xRefValueRequired)

    /* Y axis runtime errors */
    %__runtimeValidation(
        %sysevalf(&yAxisMin= 1 AND &yAxisMinValue = ),
        %__tranmsg(&error_genericValueRequired2, %__formatLabel(&errorLabel_minimumValue), %__formatLabel(&errorLabel_yAxis))
    )
    %__runtimeValidation(
        %sysevalf(&yAxisMax = 1 AND &yAxisMaxValue = ),
        %__tranmsg(&error_genericValueRequired2, %__formatLabel(&errorLabel_maximumValue), %__formatLabel(&errorLabel_yAxis))
    )
    %__runtimeValidation(
        %sysevalf(&displayYLabel = customLabel AND &yLabel = ),
        %__tranmsg(&error_genericValueRequired2, %__formatLabel(&errorLabel_label), %__formatLabel(&errorLabel_yAxis))
    )
    %__runtimeValidation(
        %sysevalf(&setYRefLineValue = 1 AND &yRefLabelRadio = yRefCustom AND &yRefCustomLabel = ),
        &error_yRefLabelRequired
    )
    %__runtimeValidation(
        %sysevalf(&yAxisMin = 1 AND &yAxisMax = 1 AND &yAxisMinValue > &yAxisMaxValue),
        &error_yAxisMaxLtMin
    )
    %__runtimeValidation(%sysevalf(&setYRefLineValue = 1 AND &yRefLineValue = ), &error_yRefValueRequired)

    /* Title and footnote runtime errors */
    %__runtimeValidation(
        %sysevalf(&titleString NE AND (%sysfunc(floor(&titleSize)) NE &titleSize OR &titleSize < 5 OR &titleSize > 24)),
        %__tranmsg(
            &error_genericIntInRange2,
            %__formatLabel(&errorLabel_fontSize),
            %__formatLabel(&errorLabel_title),
            5,
            24
        )
    )

    %__runtimeValidation(
        %sysevalf(&footnoteString NE AND (%sysfunc(floor(&footnoteSize)) NE &footnoteSize OR &footnoteSize < 5 OR &footnoteSize > 20)),
        %__tranmsg(
            &error_genericIntInRange2,
            %__formatLabel(&errorLabel_fontSize),
            %__formatLabel(&errorLabel_footnote),
            5,
            20
        )
    )

    /* Graph size runtime errors */
    %__runtimeValidation(
        %sysevalf(&graphUnits = in AND (&inchWidth < 2 OR &inchWidth > 12)),
        &error_inchWidthInvalidRange
    )
    %__runtimeValidation(
        %sysevalf(&graphUnits = in AND (&inchHeight < 2 OR &inchHeight > 12)),
        &error_inchHeightInvalidRange
    )
    %__runtimeValidation(
        %sysevalf(&graphUnits = cm AND (&cmWidth < 5 OR &cmWidth > 30)),
        &error_cmWidthInvalidRange
    )
    %__runtimeValidation(
        %sysevalf(&graphUnits = cm AND (&cmHeight < 5 OR &cmHeight > 30)),
        &error_cmHeightInvalidRange
    )
    %__runtimeValidation(
        %sysevalf(&graphUnits = px AND ((&pixelWidth < 200 OR &pixelWidth > 1200) OR (%sysfunc(floor(&pixelWidth)) NE &pixelWidth))),
        &error_pixelWidthInvalidRange
    )
    %__runtimeValidation(
        %sysevalf(&graphUnits = px AND ((&pixelHeight < 200 OR &pixelHeight > 1200) OR (%sysfunc(floor(&pixelHeight)) NE &pixelHeight))),
        &error_pixelHeightInvalidRange
    )

    /* If we have accumulated any error messages, handle them now and
       stop generating any step code. */
    %if &__errorMsg_count > 0 %then %do;
        /* Insert the localised step name into the generic message and change {1} to {0}
           within the string. */
        %__processErrors(%__tranmsg(&error_errorsInStep, &errorLabel_stepName, {0}))
        %return; /* This %RETURN statement is necessary - do not remove it. */
    %end;

    /* --------------------- */
    /* -- Code Generation -- */
    %let _dataset = &dataSource;

    /* Graph size and units */
    %let _width =;
    %let _height =;
    %if &graphUnits = in %then %do;
        %let _width = &inchWidth.%str(in);
        %let _height = &inchHeight.%str(in);
    %end;
    %if &graphUnits = cm %then %do;
        %let _width = &cmWidth.%str(cm);
        %let _height = &cmHeight.%str(cm);
    %end;
    %if &graphUnits = px %then %do;
        %let _width = &pixelWidth.%str(px);
        %let _height = &pixelHeight.%str(px);
    %end;

    /* Title and footnotes */
    %let _filterString = %bquote(%trim(&dataSource_WhereClause));

    %if &titleString NE %then %do;
        %let _title = title height=&titleSize.pt %sysfunc(quote(&titleString));
    %end;

    %if &footnoteString NE %then %do;
        %let _footnote = footnote2 justify=left height=&footnoteSize.pt %sysfunc(quote(&footnoteString));
    %end;

    %if (&_filterString NE AND &includeAsFootnote = 1) %then %do;
        %let _filterFootnote = footnote justify=left height=&footnoteSize.pt %qsysfunc(quote(%__tranmsg(&footnote_whereFootnote, &_filterString)));
    %end;

    /* Histogram statement */
    %let _histogramStatement = histogram &response /;
    %if &scale NE percent %then %do;
        %let _histogramStatement = &_histogramStatement scale=&scale;
    %end;

    %if &showTickMarks = 1 %then %do;
        %let _histogramStatement = &_histogramStatement showbins;
    %end;

    /* Specify number of bins */
    %if &setNumBins = 1 %then %do;
        %let _histogramStatement = &_histogramStatement nbins=&numBins;
    %end;

    /* Fill attributes */
    %if (&setBinColor = 1 AND &binColor NE) OR &colorTransparency NE 0 %then %do;
        %let _setAttrs = Yes;
    %end;
    %else %do;
        %let _setAttrs = No;
    %end;

    %if &_setAttrs = Yes %then %do;
        %if &setBinColor = 1 AND &colorTransparency NE 0 %then %do;
            %let _histogramStatement = &_histogramStatement fillattrs=(color=CX&binColor transparency=&colorTransparency);
        %end;
        %else %if &setBinColor = 1 %then %do;
            %let _histogramStatement = &_histogramStatement fillattrs=(color=CX&binColor);
        %end;
        %else %if &colorTransparency NE 0 %then %do;
            %let _histogramStatement = &_histogramStatement fillattrs=(transparency=&colorTransparency);
        %end;
    %end;

    /* Fill type and effect */
    %if &applyColorGradient = 1 %then %do;
        %let _histogramStatement = &_histogramStatement filltype=gradient;
        %if &colorGradient NE none AND &colorGradient NE sheen %then %do;
            %let _histogramStatement = &_histogramStatement dataskin=&colorGradient;
        %end;
    %end;
    %else %do;
        %if &colorGradient NE none %then %do;
            %let _histogramStatement = &_histogramStatement dataskin=&colorGradient;
        %end;
    %end;

    /* Weight */
    %if &weight_count > 0 %then %do;
        %let _histogramStatement = &_histogramStatement weight=&weight;
    %end;

    /* xaxis statement */
    %if &xAxisMin = 1 OR &xAxisMax = 1 OR &showXGridLines = 1 OR &displayXLabel NE defaultLabel OR &setXRotation = 1 %then %do;
        %let _xAxisStatement = xaxis;
        %if &xAxisMin = 1 %then %do;
            %let _xAxisStatement = &_xAxisStatement min=&xAxisMinValue;
        %end;
        %if &xAxisMax = 1 %then %do;
            %let _xAxisStatement = &_xAxisStatement max=&xAxisMaxValue;
        %end;
        %if &showXGridLines = 1 %then %do;
            %let _xAxisStatement = &_xAxisStatement grid;
        %end;
        %if &displayXLabel = noLabel %then %do;
            %let _xAxisStatement = &_xAxisStatement display=(nolabel);
        %end;
        %else %if &displayXLabel = customLabel %then %do;
            %let _xAxisStatement = &_xAxisStatement label=%sysfunc(quote(&xLabel));
        %end;
        %if &setXRotation = 1 %then %do;
            %let _xAxisStatement = &_xAxisStatement valuesrotate=&xRotationValue;
        %end;
    %end;

    /* yaxis statement */
    %if &yAxisMin = 1 OR &yAxisMax = 1 OR &showYGridLines = 1 OR &displayYLabel NE defaultLabel %then %do;
        %let _yAxisStatement = yaxis;
        %if &yAxisMin = 1 %then %do;
            %let _yAxisStatement = &_yAxisStatement min=&yAxisMinValue;
        %end;
        %if &yAxisMax = 1 %then %do;
            %let _yAxisStatement = &_yAxisStatement max=&yAxisMaxValue;
        %end;
        %if &showYGridLines = 1 %then %do;
            %let _yAxisStatement = &_yAxisStatement grid;
        %end;
        %if &displayYLabel = noLabel %then %do;
            %let _yAxisStatement = &_yAxisStatement display=(nolabel);
        %end;
        %else %if &displayYLabel = customLabel %then %do;
            %let _yAxisStatement = &_yAxisStatement label=%sysfunc(quote(&yLabel));
        %end;
    %end;

    /* xaxis reflines */
    %if &setXRefLineValue = 1 %then %do;
        %if &xRefLabelRadio = xRefValue %then %do;
            %let _xRefLineStatement = refline &xRefLineValue / axis=x lineattrs=(thickness=2 color=blue) label labelattrs=(color=blue);
        %end;
        %else %do;
            %let _xRefLineStatement = refline &xRefLineValue / axis=x lineattrs=(thickness=2 color=blue) label=%sysfunc(quote(&xRefCustomLabel)) labelattrs=(color=blue);
        %end;
    %end;

    /* yaxis reflines */
    %if &setYRefLineValue = 1 %then %do;
        %if &yRefLabelRadio = yRefValue %then %do;
            %let _yRefLineStatement = refline &yRefLineValue / axis=y lineattrs=(thickness=2 color=green) label labelattrs=(color=green);
        %end;
        %else %do;
            %let _yRefLineStatement = refline &yRefLineValue / axis=y lineattrs=(thickness=2 color=green) label=%sysfunc(quote(&yRefCustomLabel)) labelattrs=(color=green);
        %end;
    %end;

    /********************************/
    /* Assemble the code statements */
    /********************************/

    /* ODS, graph size */
    %__code(ods graphics / reset width=&_width height=&_height imagemap)

    /* Sort procdeure */
    %if &byVar_count > 0 %then %do;
        %__code(proc sort data=&_dataset out=WORK._HistogramTempData)
        %__code(by &byVar)
        %__code(run)
        %let _dataset = WORK._HistogramTempData;
    %end;

    /* SGPLOT proc statement */
    %let _procStatement = proc sgplot data=&_dataset;
    %if &_filterString NE %then %do;
        %let _procStatement = &_procStatement (where=(&_filterString));
    %end;
    %__code(&_procStatement)

    /* Group by */
    %if(&byVar_count > 0) %then %do;
        %__code(by &byVar)
    %end;

    /* Title and footnotes */
    %if &titleString NE %then %do;
        %__code(&_title)
    %end;

    %if (&_filterString NE AND &includeAsFootnote = 1) %then %do;
        %__code(&_filterFootnote)
    %end;

    %if &footnoteString NE %then %do;
        %__code(&_footnote)
    %end;

    /* Histogram */
    %__code(&_histogramStatement)

    /* Density curves */
    %if &normalDensity = 1 %then %do;
        %__code(density &response)
    %end;

    %if &kernelDensity = 1 %then %do;
        %__code(density &response / type=Kernel)
    %end;

    /* X axis */
    %if &xAxisMin = 1 OR &xAxisMax = 1 OR &showXGridLines = 1 OR &displayXLabel NE defaultLabel OR &setXRotation = 1 %then %do;
        %__code(&_xAxisStatement)
    %end;

    /* Y axis */
    %if &yAxisMin = 1 OR &yAxisMax = 1 OR &showYGridLines = 1 OR &displayYLabel NE defaultLabel %then %do;
        %__code(&_yAxisStatement)
    %end;

    /* X axis reflines */
    %if &setXRefLineValue = 1 %then %do;
        %__code(&_xRefLineStatement)
    %end;

    /* Y axis reflines */
    %if &setYRefLineValue = 1 %then %do;
        %__code(&_yRefLineStatement)
    %end;

    /* Legend location */
    %if (&normalDensity = 1 OR &kernelDensity = 1) AND &legendLocation = inside %then %do;
        %if &normalDensity = 1 AND &kernelDensity = 1 %then %do;
            %__code(keylegend "DENSITY" "DENSITY1" / location=inside position=topright across=1)
        %end;
        %else %do;
            %__code(keylegend "DENSITY" / location=inside position=topright across=1)
        %end;
    %end;

    /* SGPLOT proc statement ends */
    %__code(run)

    /* Clean up */
    %__code(ods graphics / reset)

    %if &titleString NE %then %do;
        %__code(title)
    %end;

    %if ((&_filterString NE AND &includeAsFootnote = 1) OR &footnoteString NE) %then %do;
        %__code(footnote)
    %end;

    %if &byVar_count > 0 %then %do;
        %__code(proc delete data=WORK._HistogramTempData)
        %__code(run)
    %end;

%mend runStep;

/* ************************************************************************* */
/* Main entry point: All the work is done in the macro. */
%let __locallyDefinedEntryPointMacro = 0;
%if %sysmacexist(__entryPoint) = 0 %then %do;
    %let __locallyDefinedEntryPointMacro = 1;
    %macro __entryPoint();
        %runStep()
    %mend __entryPoint;
%end;

options mprint;
%__entryPoint()

/* ************************************************************************* */
/* Tidy up macros and macro variables that have been defined. */
%sysmacdelete __formatLabel;
%sysmacdelete __tranmsg;

/* If we created a local __entryPoint macro, remove it. */
%if &__locallyDefinedEntryPointMacro = 1 %then %do;
    %sysmacdelete __entryPoint;
%end;
%symdel __locallyDefinedEntryPointMacro;

/* If we created a local __processErrors macro, remove it. */
%if &__locallyDefinedProcErrsMacro = 1 %then %do;
    %sysmacdelete __processErrors;
%end;
%symdel __locallyDefinedProcErrsMacro;

/* If we created a local __code macro, remove it. */
%if &__locallyDefinedCodeMacro = 1 %then %do;
    %sysmacdelete __code;
%end;
%symdel __locallyDefinedCodeMacro;

/* SAS code provided in template section of Custom Step - END */

/* region: Generated macro cleanup */

/* Cleanup macros and macro variables - BEGIN */
/* Delete macro variables created in this step */

%_flw_del_macro_vars( applyColorGradient );
%_flw_del_macro_vars( binColor );
%_flw_del_macro_vars( byVar byVar_count );
%_flw_del_macro_vars( cmHeight );
%_flw_del_macro_vars( cmWidth );
%_flw_del_macro_vars( colorGradient );
%_flw_del_macro_vars( colorTransparency );
%_flw_del_macro_vars( dataSource dataSource_engine dataSource_label dataSource_lib dataSource_name dataSource_name_base
                  dataSource_type );
%_flw_del_macro_vars( dataSource_WhereClause );
%_flw_del_macro_vars( displayXLabel );
%_flw_del_macro_vars( displayYLabel );
%_flw_del_macro_vars( errorLabel_analysisVariable );
%_flw_del_macro_vars( errorLabel_fontSize );
%_flw_del_macro_vars( errorLabel_footnote );
%_flw_del_macro_vars( errorLabel_inputData );
%_flw_del_macro_vars( errorLabel_label );
%_flw_del_macro_vars( errorLabel_maximumValue );
%_flw_del_macro_vars( errorLabel_minimumValue );
%_flw_del_macro_vars( errorLabel_numberOfBins );
%_flw_del_macro_vars( errorLabel_stepName );
%_flw_del_macro_vars( errorLabel_title );
%_flw_del_macro_vars( errorLabel_xAxis );
%_flw_del_macro_vars( errorLabel_yAxis );
%_flw_del_macro_vars( error_cmHeightInvalidRange );
%_flw_del_macro_vars( error_cmWidthInvalidRange );
%_flw_del_macro_vars( error_errorsInStep );
%_flw_del_macro_vars( error_genericIntInRange );
%_flw_del_macro_vars( error_genericIntInRange2 );
%_flw_del_macro_vars( error_genericTableInfoIncomplete );
%_flw_del_macro_vars( error_genericValueRequired );
%_flw_del_macro_vars( error_genericValueRequired2 );
%_flw_del_macro_vars( error_genericVarRequired );
%_flw_del_macro_vars( error_inchHeightInvalidRange );
%_flw_del_macro_vars( error_inchWidthInvalidRange );
%_flw_del_macro_vars( error_pixelHeightInvalidRange );
%_flw_del_macro_vars( error_pixelWidthInvalidRange );
%_flw_del_macro_vars( error_xAxisMaxLtMin );
%_flw_del_macro_vars( error_xRefLabelRequired );
%_flw_del_macro_vars( error_xRefValueRequired );
%_flw_del_macro_vars( error_yAxisMaxLtMin );
%_flw_del_macro_vars( error_yRefLabelRequired );
%_flw_del_macro_vars( error_yRefValueRequired );
%_flw_del_macro_vars( footnoteSize );
%_flw_del_macro_vars( footnoteString );
%_flw_del_macro_vars( footnote_whereFootnote );
%_flw_del_macro_vars( graphUnits );
%_flw_del_macro_vars( inchHeight );
%_flw_del_macro_vars( inchWidth );
%_flw_del_macro_vars( includeAsFootnote );
%_flw_del_macro_vars( kernelDensity );
%_flw_del_macro_vars( legendLocation );
%_flw_del_macro_vars( normalDensity );
%_flw_del_macro_vars( numBins );
%_flw_del_macro_vars( pixelHeight );
%_flw_del_macro_vars( pixelWidth );
%_flw_del_macro_vars( response response_count response_1_format response_1_informat response_1_label response_1_name
                  response_1_name_base response_1_rawlength response_1_type );
%_flw_del_macro_vars( scale );
%_flw_del_macro_vars( setBinColor );
%_flw_del_macro_vars( setNumBins );
%_flw_del_macro_vars( setXRefLineValue );
%_flw_del_macro_vars( setXRotation );
%_flw_del_macro_vars( setYRefLineValue );
%_flw_del_macro_vars( showTickMarks );
%_flw_del_macro_vars( showXGridLines );
%_flw_del_macro_vars( showYGridLines );
%_flw_del_macro_vars( titleSize );
%_flw_del_macro_vars( titleString );
%_flw_del_macro_vars( weight weight_count );
%_flw_del_macro_vars( xAxisMax );
%_flw_del_macro_vars( xAxisMaxValue );
%_flw_del_macro_vars( xAxisMin );
%_flw_del_macro_vars( xAxisMinValue );
%_flw_del_macro_vars( xLabel );
%_flw_del_macro_vars( xRefCustomLabel );
%_flw_del_macro_vars( xRefLabelRadio );
%_flw_del_macro_vars( xRefLineValue );
%_flw_del_macro_vars( xRotationValue );
%_flw_del_macro_vars( yAxisMax );
%_flw_del_macro_vars( yAxisMaxValue );
%_flw_del_macro_vars( yAxisMin );
%_flw_del_macro_vars( yAxisMinValue );
%_flw_del_macro_vars( yLabel );
%_flw_del_macro_vars( yRefCustomLabel );
%_flw_del_macro_vars( yRefLabelRadio );
%_flw_del_macro_vars( yRefLineValue );
/* Delete macros defined in this step */
%_flw_del_macros(_flw_get_column_list _flw_del_macro_vars);

/* Cleanup macros and macro variables - END */

%sysmacdelete _flw_del_macros;

/* endregion */


/* region: Generated step cleanup for Histogram */
%_flw_action_end(id-1751183183329-38307, , , );
/* endregion */

/*===========================================================================*
* Node name:        Box Plot
* Node ID:          id-1751183256837-39171
*
* Input Tables:
*   WORK.Final
*
* Step name:        Box Plot
* Step path:        /dataFlows/steps/ab71a6ee-26c8-4124-bf9d-fc5f6f5c6ad2
* Step description: Box Plot represents numeric values measured as intervals.
*----------------------------------------------------------------------------*/

/* region: Generated step setup */
%_flw_action_start(id-1751183256837-39171);
/* endregion */

/* region: Generated macro initialization */

/* Define utility macros - BEGIN */

/* Macro to get a list of column names */
%macro _flw_get_column_list(_flw_prefix = %nrstr(), _delim=%str( ));
   %do _flw_index=1 %to %unquote(&&&_flw_prefix._count);%unquote(&&&_flw_prefix._&_flw_index._name)%if &_flw_index.<%unquote(&&&_flw_prefix._count)%then&_delim.; %end;
%mend;

/* Macro to delete macro variables with names passed in */
%macro _flw_del_macro_vars(_flw_macro_vars_to_delete,_flw_no_warn=Y);
   %if "&_flw_no_warn"="Y" %then %symdel &_flw_macro_vars_to_delete/NOWARN;
   %else %symdel &_flw_macro_vars_to_delete;
%mend;

/* Macro to delete a list of macros with names passed in */
%macro _flw_del_macros(_flw_macro_names,_flw_no_warn=Y);
   %let num=1;
   %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %do %while (&_flw_local_macros_to_delete ne );
      %if "&_flw_no_warn"="Y" %then %sysmacdelete &_flw_local_macros_to_delete/NOWARN;
      %else %sysmacdelete &_flw_local_macros_to_delete;
      %let num=%eval(&num+1);
      %let _flw_local_macros_to_delete=%scan(&_flw_macro_names,&num);
   %end;
%mend;

/* Define utility macros - END */

/* Macro variables derived from user input to this step - BEGIN */

/* Macro variable(s) for UI control with ID of boxColor */
%let boxColor=CAD5E5;

/* Macro variable(s) for UI control with ID of boxOrient */
%let boxOrient=vertical;

/* Macro variable(s) for UI control with ID of boxSkin */
%let boxSkin=none;

/* Macro variable(s) for UI control with ID of boxWidth */
%let boxWidth=0.4;

/* Macro variable(s) for UI control with ID of boxWidthGrp */
%let boxWidthGrp=0.6;

/* Macro variable(s) for UI control with ID of byVar */
%let byVar=;
%let byVar_count=0;

/* Macro variable(s) for UI control with ID of capShape */
%let capShape=serif;

/* Macro variable(s) for UI control with ID of catLabel */
%let catLabel=;

/* Macro variable(s) for UI control with ID of catLabelRotation */
%let catLabelRotation=0;

/* Macro variable(s) for UI control with ID of catRefCustomLabel */
%let catRefCustomLabel=;

/* Macro variable(s) for UI control with ID of catRefLabel */
%let catRefLabel=catRefValue;

/* Macro variable(s) for UI control with ID of catRefLine */
%let catRefLine=0;

/* Macro variable(s) for UI control with ID of catRefLineLevel */
%let catRefLineLevel=;

/* Macro variable(s) for UI control with ID of catRefLineOffset */
%let catRefLineOffset=zero;

/* Macro variable(s) for UI control with ID of catReverse */
%let catReverse=0;

/* Macro variable(s) for UI control with ID of catTickRotate */
%let catTickRotate=catDiagonalRotation;

/* Macro variable(s) for UI control with ID of category */
%let category=emp_length;
%let category_count=1;

/* Macro variables for column <emp_length> */
%let category_1_format=$9.;
%let category_1_informat=$9.;
%let category_1_label=;
%let category_1_name=emp_length;
%let category_1_name_base=emp_length;
%let category_1_rawlength=9;
%let category_1_type=Character;

/* Macro variable(s) for UI control with ID of cmHeight */
%let cmHeight=12;

/* Macro variable(s) for UI control with ID of cmWidth */
%let cmWidth=16;

/* Macro variable(s) for UI control with ID of dataSource */
%let dataSource=WORK.Final;
%let dataSource_engine=V9;
%let dataSource_label=;
%let dataSource_lib=WORK;
%let dataSource_name=Final;
%let dataSource_name_base=Final;
%let dataSource_type=;

/* Macro variable(s) for UI control with ID of dataSource_WhereClause */
%let dataSource_WhereClause=;

/* Macro variable(s) for UI control with ID of dimType */
%let dimType=%nrquote(in);

/* Macro variable(s) for UI control with ID of displayCatLabel */
%let displayCatLabel=defaultLabel;

/* Macro variable(s) for UI control with ID of displayRespLabel */
%let displayRespLabel=defaultLabel;

/* Macro variable(s) for UI control with ID of errorLabel_analysisAxis */
%let errorLabel_analysisAxis=%nrquote(Analysis Axis);

/* Macro variable(s) for UI control with ID of errorLabel_analysisVar */
%let errorLabel_analysisVar=%nrquote(Analysis variable:);

/* Macro variable(s) for UI control with ID of errorLabel_boxes */
%let errorLabel_boxes=Boxes;

/* Macro variable(s) for UI control with ID of errorLabel_fontSize */
%let errorLabel_fontSize=%nrquote(Font size %(default: 14 pt%):);

/* Macro variable(s) for UI control with ID of errorLabel_footnote */
%let errorLabel_footnote=Footnote:;

/* Macro variable(s) for UI control with ID of errorLabel_inputData */
%let errorLabel_inputData=%nrquote(Input data:);

/* Macro variable(s) for UI control with ID of errorLabel_stepName */
%let errorLabel_stepName=%nrquote(Box Plot);

/* Macro variable(s) for UI control with ID of errorLabel_title */
%let errorLabel_title=Title:;

/* Macro variable(s) for UI control with ID of errorLabel_width */
%let errorLabel_width=%nrquote(Width %(default: 0.4%):);

/* Macro variable(s) for UI control with ID of error_catLabelRequired */
%let error_catLabelRequired=%nrquote(A value is required for the %'Category Axis label%'.);

/* Macro variable(s) for UI control with ID of error_catRefLabelRequired */
%let error_catRefLabelRequired=%nrquote(A value is required for the %'Category Axis reference custom label%'.);

/* Macro variable(s) for UI control with ID of error_catRefValueRequired */
%let error_catRefValueRequired=%nrquote(A value is required for the %'Category Axis reference value as label%'.);

/* Macro variable(s) for UI control with ID of error_cmHeightInvalidRange */
%let error_cmHeightInvalidRange=%nrquote(%'Graph size height%' requires a number greater than or equal to 5 and less than or equal to 30 for the height in centimeters.);

/* Macro variable(s) for UI control with ID of error_cmWidthInvalidRange */
%let error_cmWidthInvalidRange=%nrquote(%'Graph size width%' requires a number greater than or equal to 5 and less than or equal to 30 for the width in centimeters.);

/* Macro variable(s) for UI control with ID of error_errorsInStep */
%let error_errorsInStep=%nrquote(The {0} step contained the following {1} errors and could not be run:);

/* Macro variable(s) for UI control with ID of error_inchHeightInvalidRange */
%let error_inchHeightInvalidRange=%nrquote(%'Graph size height%' requires a number greater than or equal to 2 and less than or equal to 12 for the height in inches.);

/* Macro variable(s) for UI control with ID of error_inchWidthInvalidRange */
%let error_inchWidthInvalidRange=%nrquote(%'Graph size width%' requires a number greater than or equal to 2 and less than or equal to 12 for the width in inches.);

/* Macro variable(s) for UI control with ID of error_integerInRange2 */
%let error_integerInRange2=%nrquote(The {0} property for {1} requires an integer greater than or equal to {2} and less than or equal to {3}.);

/* Macro variable(s) for UI control with ID of error_maxValueRequired */
%let error_maxValueRequired=%nrquote(A maximum value is required for {0}.);

/* Macro variable(s) for UI control with ID of error_minValueRequired */
%let error_minValueRequired=%nrquote(A minimum value is required for {0}.);

/* Macro variable(s) for UI control with ID of error_numberInRange2 */
%let error_numberInRange2=%nrquote(The {0} property for {1} requires a number greater than or equal to {2} and less than or equal to {3}.);

/* Macro variable(s) for UI control with ID of error_pixelHeightInvalidRange */
%let error_pixelHeightInvalidRange=%nrquote(%'Graph size height%' requires an integer greater than or equal to 200 and less than or equal to 1200 for the height in pixels.);

/* Macro variable(s) for UI control with ID of error_pixelWidthInvalidRange */
%let error_pixelWidthInvalidRange=%nrquote(%'Graph size width%' requires an integer greater than or equal to 200 and less than or equal to 1200 for the width in pixels.);

/* Macro variable(s) for UI control with ID of error_resLabelRequired */
%let error_resLabelRequired=%nrquote(A value is required for the %'Analysis Axis custom label%'.);

/* Macro variable(s) for UI control with ID of error_resRefLabelRequired */
%let error_resRefLabelRequired=%nrquote(A value is required for the %'Analysis Axis reference custom label%'.);

/* Macro variable(s) for UI control with ID of error_resRefValueRequired */
%let error_resRefValueRequired=%nrquote(A value is required for the %'Analysis Axis reference value as label%'.);

/* Macro variable(s) for UI control with ID of error_respAxisMaxLtMin */
%let error_respAxisMaxLtMin=%nrquote(The %'Analysis Axis%' %'Maximum value%' should be greater than or equal to the %'Minimum value%'.);

/* Macro variable(s) for UI control with ID of error_tableInfoIncomplete */
%let error_tableInfoIncomplete=%nrquote(The {0} table information is incomplete. Either the %'Library%' or %'Table name%' is empty.);

/* Macro variable(s) for UI control with ID of error_variableRequired */
%let error_variableRequired=%nrquote({0} requires the selection of a variable.);

/* Macro variable(s) for UI control with ID of fillTrans */
%let fillTrans=0;

/* Macro variable(s) for UI control with ID of footnoteSize */
%let footnoteSize=12;

/* Macro variable(s) for UI control with ID of footnoteString */
%let footnoteString=;

/* Macro variable(s) for UI control with ID of footnote_whereFootnote */
%let footnote_whereFootnote=%nrquote(Where clause: {0});

/* Macro variable(s) for UI control with ID of group */
%let group=;
%let group_count=0;

/* Macro variable(s) for UI control with ID of groupOrder */
%let groupOrder=data;

/* Macro variable(s) for UI control with ID of inchHeight */
%let inchHeight=4.8;

/* Macro variable(s) for UI control with ID of inchWidth */
%let inchWidth=6.4;

/* Macro variable(s) for UI control with ID of includeAsFootnote */
%let includeAsFootnote=0;

/* Macro variable(s) for UI control with ID of legendLoc */
%let legendLoc=outside;

/* Macro variable(s) for UI control with ID of logAxis */
%let logAxis=0;

/* Macro variable(s) for UI control with ID of logBaseCombo */
%let logBaseCombo=10;

/* Macro variable(s) for UI control with ID of notches */
%let notches=0;

/* Macro variable(s) for UI control with ID of pixelHeight */
%let pixelHeight=480;

/* Macro variable(s) for UI control with ID of pixelWidth */
%let pixelWidth=640;

/* Macro variable(s) for UI control with ID of respAxisMax */
%let respAxisMax=0;

/* Macro variable(s) for UI control with ID of respAxisMaxValue */
%let respAxisMaxValue=;

/* Macro variable(s) for UI control with ID of respAxisMin */
%let respAxisMin=0;

/* Macro variable(s) for UI control with ID of respAxisMinValue */
%let respAxisMinValue=;

/* Macro variable(s) for UI control with ID of respLabel */
%let respLabel=;

/* Macro variable(s) for UI control with ID of respLabelRotation */
%let respLabelRotation=0;

/* Macro variable(s) for UI control with ID of respRefCustomLabel */
%let respRefCustomLabel=;

/* Macro variable(s) for UI control with ID of respRefLabel */
%let respRefLabel=respRefValue;

/* Macro variable(s) for UI control with ID of respRefLine */
%let respRefLine=0;

/* Macro variable(s) for UI control with ID of respRefLineValue */
%let respRefLineValue=;

/* Macro variable(s) for UI control with ID of respTickRotate */
%let respTickRotate=respDiagonalRotation;

/* Macro variable(s) for UI control with ID of response */
%let response=interest_rate_clean;
%let response_count=1;

/* Macro variables for column <interest_rate_clean> */
%let response_1_format=;
%let response_1_informat=;
%let response_1_label=;
%let response_1_name=interest_rate_clean;
%let response_1_name_base=interest_rate_clean;
%let response_1_rawlength=8;
%let response_1_type=Numeric;

/* Macro variable(s) for UI control with ID of setColor */
%let setColor=0;

/* Macro variable(s) for UI control with ID of showRespGrid */
%let showRespGrid=1;

/* Macro variable(s) for UI control with ID of sortByData */
%let sortByData=0;

/* Macro variable(s) for UI control with ID of titleSize */
%let titleSize=14;

/* Macro variable(s) for UI control with ID of titleString */
%let titleString=;

/* Macro variable(s) for UI control with ID of weight */
%let weight=;
%let weight_count=0;

/* Macro variables derived from user input to this step - END */

/* endregion */
/* SAS code provided in template section of Custom Step - BEGIN */
/* ************************************************************************* */
/* Box Plot provides equivalent functionality as the CTM Box Plot task.

   Release cadence: 2024.04
*/

/* ************************************************************************* */
/* Inserts values into a localized  message string at the locations
   indicated by tokens of the form `{0}` through `{9}`.
*/
%macro __tranmsg(msg  /* message text with keys {0} - {9} as needed */, value0 /* value for {0} */,
                     value1 /* value for {1} */, value2 /* value for {2} */, value3 /* value for {3} */,
                     value4 /* value for {4} */, value5 /* value for {5} */, value6 /* value for {6} */,
                     value7 /* value for {7} */, value8 /* value for {8} */, value9 /* value for {9} */);
    %local _retVal _i;
    %let _retVal = %superq(msg);
    %let _i = 0;
    %do %while (&_i <= 9 AND %index(%superq(msg), {&_i}) NE 0);
        %let _retval = %qsysfunc(tranwrd(&_retval, {&_i}, %superq(value&_i)));
        %let _i = %eval(&_i + 1);
    %end;
    %superq(_retVal)
%mend __tranmsg;

/* ************************************************************************* */
/* Wraps the supplied label value in single quotes after attempting to
   remove any trailing colon as well as any text enclosed within
   parentheses at the end of the string.
*/
%macro __formatLabel(label);
    %local _reversed _lastChar _firstParen _retVal;
    %let _retVal = ;
    %if %length(&label) NE 0 %then %do;
        %let _reversed = %qtrim(%qsysfunc(reverse(%qtrim(&label))));
        /* Look for a trailing colon and remove it if one is found. */
        %let _lastChar = %qsubstr(&_reversed, 1, 1);
        %if &_lastChar = %str(:) %then %do;
            %let _reversed = %qtrim(%qsubstr(&_reversed, 2));
        %end;
        /* Now check to see if there is text within parentheses at
           the end of the label's string. If found, remove the
           parentheses and all text enclosed. */
        %let _retVal = %qtrim(%qsysfunc(reverse(&_reversed)));
        %let _lastChar = %qsubstr(&_retVal, %length(&_retVal), 1);
        %let _firstParen = %index(&_retVal, %str(%());
        %if &_lastChar = %str(%)) AND &_firstParen > 0 %then %do;
            %let _retVal = %qtrim(%qsubstr(&_retVal, 1, &_firstParen - 1));
        %end;
    %end;
    %str(%'%superq(_retVal)%')
%mend __formatLabel;

/* ************************************************************************* */
/* The locally defined __code() macro writes the generated SAS code inline
   for execution. If an externally defined macro of that name exists, then
   we don't need to create the local version.
*/
%let __locallyDefinedCodeMacro = 0;
%if %sysmacexist(__code) = 0 %then %do;
    %let __locallyDefinedCodeMacro = 1;
    %macro __code(sasCode);
        %unquote(&sasCode);
    %mend;
%end;

/* ************************************************************************* */
/* The locally defined __processErrors() macro writes all error messages to
   the log and then aborts the processing. If an externally defined macro
   of that name exists, then we don't need to create the local version.
*/
%let __locallyDefinedProcErrsMacro = 0;
%if %sysmacexist(__processErrors) = 0 %then %do;
    %let __locallyDefinedProcErrsMacro = 1;
    %macro __processErrors(errorSummaryMsg);
        %local errorMacVar;
        %put ERROR: %sysfunc(tranwrd(&errorSummaryMsg, {0}, &__errorMsg_count));
        %do _errorMsg_index = 1 %to &__errorMsg_count;
            %let errorMacVar = __errorMsg_&_errorMsg_index;
            %put &&&errorMacVar;
            %symdel &errorMacVar;
        %end;
        %symdel __errorMsg_count;
        %abort;
    %mend;
%end;

/* ************************************************************************* */
/* Performs the validation checks. And adds the supplied message to the
    errors 'array' if the test value is true.
*/
%macro __runtimeValidation(test, msg);
    %if &test %then %do;
        %let __errorMsg_count = %eval(&__errorMsg_count + 1);
        %global __errorMsg_&__errorMsg_count;
        %let __errorMsg_&__errorMsg_count = %str(ERROR: &msg);
    %end;
%mend;

/* ************************************************************************* */
/* runStep() generates a proc sgplot to graph the input data */
%macro runStep();
    /* Globally defined so that the __processErrors macro can get
       access to it. */
    %global
        __errorMsg_count;
    /* Locally scoped macro variables so that we don't interfere with
       similarly named variables defined outside of this macro. */
    %local
        _errorMsg_index
        _width
        _height
        _sgplot
        _qTitleString
        _qFootnoteString
        _titleSizePt
        _filterString
        _footSizePt
        _setAttrs
        _catAxis
        _respAxis
        _bplot
        _catAx
        _respAx
        _catRefL
        _respRefL;

    /* ---------------- */
    /* -- Validation -- */

    %let __errorMsg_count = 0;

    /*--Data--*/
    %__runtimeValidation(
        %eval(&dataSource_lib = OR &dataSource_name = ),
        %__tranmsg(
            &error_tableInfoIncomplete,
            %__formatLabel(&errorLabel_inputData)
        )
    )

    /*--Box--*/
    %__runtimeValidation(
        %sysevalf(
            (%length(&group) = 0 AND (&boxWidth < 0 OR &boxWidth > 1)) OR
            (%length(&group) > 0 AND (&boxWidthGrp < 0 OR &boxWidthGrp > 1))
        ),
        %__tranmsg(
            &error_numberInRange2,
            %__formatLabel(&errorLabel_width),
            %__formatLabel(&errorLabel_boxes),
            0,
            1
        )
    )
    /*--Response Axis--*/
    %__runtimeValidation(
        %sysevalf(&response_count = 0),
        %__tranmsg(
            &error_variableRequired,
            %__formatLabel(&errorLabel_analysisVar)
        )
    )
    %__runtimeValidation(
        %sysevalf(&respAxisMin=1 AND &respAxisMinValue = ),
        %__tranmsg(
            &error_minValueRequired,
            %__formatLabel(&errorLabel_analysisAxis)
        )
    )
    %__runtimeValidation(
        %sysevalf(&respAxisMax=1 AND &respAxisMaxValue = ),
        %__tranmsg(
            &error_maxValueRequired,
            %__formatLabel(&errorLabel_analysisAxis)
        )
    )
    %__runtimeValidation(
        %sysevalf(&respAxisMin=1 AND &respAxisMax=1 AND &respAxisMinValue > &respAxisMaxValue),
        &error_respAxisMaxLtMin
    )
    %__runtimeValidation(%sysevalf(&displayRespLabel = customLabel AND &respLabel = ), &error_resLabelRequired)
    %__runtimeValidation(
        %sysevalf(&respRefLine=1 AND &respRefLabel = respRefCustom AND &respRefCustomLabel = ),
        &error_resRefLabelRequired
    )
    %__runtimeValidation(%sysevalf(&respRefLine=1 AND &respRefLineValue = ), &error_resRefValueRequired)
    /*--Category Axis--*/
    %__runtimeValidation(%sysevalf(&displayCatLabel = customLabel AND &catLabel = ), &error_catLabelRequired)
    %__runtimeValidation(
        %sysevalf(&catRefLine=1 AND &catRefLabel = catRefCustom AND &catRefCustomLabel = ),
        &error_catRefLabelRequired
    )
    %__runtimeValidation(%sysevalf(&catRefLine=1 AND &catRefLineLevel = ), &error_catRefValueRequired)
    /*--Title and Footnote--*/
    %__runtimeValidation(
        %sysevalf(&titleString NE AND (%sysfunc(floor(&titleSize)) NE &titleSize OR  &titleSize < 5 OR &titleSize > 24)),
        %__tranmsg(
            &error_integerInRange2,
            %__formatLabel(&errorLabel_fontSize),
            %__formatLabel(&errorLabel_title),
            5,
            24
        )
    )
    %__runtimeValidation(
        %sysevalf(&footnoteString NE AND (%sysfunc(floor(&footnoteSize)) NE &footnoteSize OR  &footnoteSize < 5 OR &footnoteSize > 20)),
        %__tranmsg(
            &error_integerInRange2,
            %__formatLabel(&errorLabel_fontSize),
            %__formatLabel(&errorLabel_footnote),
            5,
            20
        )
    )
    /*--Graph Size--*/
    %__runtimeValidation(%sysevalf(&dimType = in AND (&inchWidth < 2 OR &inchWidth > 12)), &error_inchWidthInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = in AND (&inchHeight < 2 OR &inchHeight > 12)), &error_inchHeightInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = cm AND (&cmWidth < 5 OR &cmWidth > 30)), &error_cmWidthInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = cm AND (&cmHeight < 5 OR &cmHeight > 30)), &error_cmHeightInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = px AND (&pixelWidth < 200 OR &pixelWidth > 1200)), &error_pixelWidthInvalidRange)
    %__runtimeValidation(%sysevalf(&dimType = px AND (&pixelHeight < 200 OR &pixelHeight > 1200)), &error_pixelHeightInvalidRange)

    /* If we have accumulated any error messages, handle them now and
       stop generating any step code. */
    %if &__errorMsg_count > 0 %then %do;
        /* Insert the localised step name into the generic message and change {1} to {0}
           within the string. */
        %__processErrors(%__tranmsg(&error_errorsInStep, &errorLabel_stepName, {0}))
        %return; /* This %RETURN statement is necessary - do not remove it. */
    %end;

    /* --------------------- */
    /* -- Code Generation -- */

    /*--Set Graph Size--*/
    %if &dimType=in %then %do;
        %let _width=&inchWidth&dimType;
        %let _height=&inchHeight&dimType;
    %end;

    %if &dimType=cm %then %do;
        %let _width=&cmWidth&dimType;
        %let _height=&cmHeight&dimType;
    %end;

    %if &dimType=px %then %do;
        %let _width=&pixelWidth&dimType;
        %let _height=&pixelHeight&dimType;
    %end;

    /*--Set output size--*/
    %__code(ods graphics / reset width=&_width height=&_height imagemap)

    /*--Sort data by BY variable--*/
    %if &byVar NE %then %do;
        %__code(proc sort data=&dataSource out=_BoxPlotTaskData)
        %__code(by &byVar)
        %__code(run)
    %end;

    /*--SGPLOT proc statement--*/
    %let _sgplot = proc sgplot data;
    %if &byVar NE %then %do;
        %let _sgplot = &_sgplot = _BoxPlotTaskData;
    %end;
    %else %do;
        %let _sgplot = &_sgplot = &dataSource;
    %end;
    %__code(&_sgplot)

    /*--BY Variable--*/
    %if &byVar NE %then %do;
        %__code(by &byVar)
    %end;

    /*--Where Clause--*/
    %let _filterString = %bquote(%trim(&dataSource_WhereClause));
    %if &_filterString NE %then %do;
        %__code(where %unquote(&_filterString))
    %end;

    /*--Build qouted strings for title and footnote to clean up any quotes provided by user--*/
    %if &titleString NE %then %do;
        %let _qTitleString= %sysfunc(quote(&titleString));
    %end;

    %if &footnoteString NE %then %do;
        %let _qFootnoteString= %sysfunc(quote(&footnoteString));
    %end;

    /*--TITLE and FOOTNOTE--*/

    /*--Title--*/
    %if &titleString NE %then %do;
        %let _titleSizePt= &titleSize.pt;
        %__code(title height=&_titleSizePt &_qTitleString)
    %end;

    /*--Footnote--*/
    %if &footnoteString NE OR (&dataSource_WhereClause NE AND &includeAsFootnote=1) %then %do;
        %let _footSizePt=&footnoteSize.pt;
        %if &dataSource_WhereClause NE AND &includeAsFootnote=1 %then %do;
            %__code(footnote justify=left height=&_footSizePt %qsysfunc(quote(%__tranmsg(&footnote_whereFootnote, &dataSource_WhereClause))))
        %end;
        %if &footnoteString NE %then %do;
            %__code(footnote2 justify=left height=&_footSizePt &_qFootnoteString)
        %end;
    %end;

    /*--Box Plot settings--*/
    %if (&setColor NE AND &setColor=1) OR &fillTrans NE 0 %then %do;
        %let _setAttrs=Yes;
    %end;
    %else %do;
        %let _setAttrs=No;
    %end;

    %let _bplot = ;
    %if &boxOrient=vertical %then %do;
        %let _bplot = vbox;
    %end;
    %else %do;
        %let _bplot = hbox;
    %end;

    %let _bplot = &_bplot &response /;

    %if &category NE %then %do;
        %let _bplot = &_bplot category=&category;
    %end;

    %if &group NE %then %do;
        %let _bplot = &_bplot group=&group;
        %if &groupOrder NE data %then %do;
            %let _bplot = &_bplot grouporder=&groupOrder;
        %end;
    %end;

    %if &group NE %then %do;
        %if &boxWidthGrp NE 0.6 %then %do;
            %let _bplot = &_bplot boxwidth=&boxWidthGrp;
        %end;
    %end;
    %else %do;
        %if &boxWidth NE 0.4 %then %do;
            %let _bplot = &_bplot boxwidth=&boxWidth;
        %end;
    %end;

    %if &_setAttrs=Yes %then %do;
        %let _bplot = &_bplot fillattrs=(;
        %if &setColor=1 %then %do;
            %let _bplot = &_bplot color=CX&boxColor;
        %end;
        %if &fillTrans NE 0 %then %do;
            %if &fillTrans = 25percent %then %do;
                %let _bplot = &_bplot transparency=0.25;
            %end;
            %else %if &fillTrans = 50percent %then %do;
                %let _bplot = &_bplot transparency=0.5;
            %end;
            %else %if &fillTrans = 75percent %then %do;
                %let _bplot = &_bplot transparency=0.75;
            %end;
            %else %do;
                %let _bplot = &_bplot transparency=1;
            %end;
        %end;
        %let _bplot = &_bplot );
    %end;

    %if &notches=1 %then %do;
        %let _bplot = &_bplot notches;
    %end;

    %if &boxSkin NE none %then %do;
        %let _bplot = &_bplot dataskin=&boxSkin;
    %end;

    %if &capShape NE serif %then %do;
        %let _bplot = &_bplot capshape=&capShape;
    %end;

    %if &weight NE %then %do;
        %let _bplot = &_bplot weight=&weight;
    %end;
    %__code(&_bplot)

    /*--Category Axis--*/
    %let _catAxis=0;
    %if (&displayCatLabel NE AND &displayCatLabel NE defaultLabel) OR &sortByData=1 OR &catReverse=1 OR &catLabelRotation=1 %then %do;
        %let _catAxis=1;
    %end;
    %let _catAx = ;
    %if &_catAxis=1 %then %do;
        %if &boxOrient=vertical %then %do;
            %let _catAx = xaxis;
        %end;

        %else %do;
            %let _catAx = yaxis;
        %end;

        %if &sortByData=1 %then %do;
            %let _catAx = &_catAx discreteorder=data;
        %end;

        %if &catReverse=1 %then %do;
            %let _catAx = &_catAx reverse;
        %end;

        %if &displayCatLabel=noLabel %then %do;
            %let _catAx = &_catAx display=(nolabel);
        %end;

        %if &displayCatLabel=customLabel %then %do;
            %let _catAx = &_catAx label=%sysfunc(quote(%qtrim(&catLabel)));
        %end;

        %if &boxOrient = vertical AND &catLabelRotation=1 %then %do;
            %let _catAx = &_catAx valuesrotate;
            %if &catTickRotate=catDiagonalRotation %then %do;
                %let _catAx = &_catAx = diagonal;
            %end;
            %else %do;
                %let _catAx = &_catAx = vertical;
            %end;
        %end;
        %__code(&_catAx)
    %end;

    /*--Response Axis--*/
    %let _respAxis=0;
    %if &displayRespLabel NE defaultLabel OR &showRespGrid=1 OR &logAxis=1 OR &respLabelRotation=1 OR &respAxisMin=1 OR &respAxisMax=1 %then %do;
        %let _respAxis=1;
    %end;
    %let _respAx = ;
    %if &_respAxis=1 %then %do;
        %if &boxOrient=vertical %then %do;
            %let _respAx = yaxis;
        %end;
        %else %do;
            %let _respAx = xaxis;
        %end;

        %if &respAxisMin=1 %then %do;
            %let _respAx = &_respAx min=&respAxisMinValue;
        %end;

        %if &respAxisMax=1 %then %do;
            %let _respAx = &_respAx max=&respAxisMaxValue;
        %end;

        %if &showRespGrid=1 %then %do;
            %let _respAx = &_respAx grid;
        %end;

        %if &displayRespLabel=noLabel %then %do;
            %let _respAx = &_respAx display=(nolabel);
        %end;

        %if &displayRespLabel=customLabel %then %do;
            %let _respAx = &_respAx label=%sysfunc(quote(%qtrim(&respLabel)));
        %end;

        %if &logAxis=1 %then %do;
            %let _respAx = &_respAx type=log;
            %if &logBaseCombo NE 10 %then %do;
                %let _respAx = &_respAx logbase=&logBaseCombo;
            %end;
        %end;

        %if &boxOrient = horizontal AND &respLabelRotation=1 %then %do;
            %let _respAx = &_respAx valuesrotate;
            %if &respTickRotate=respDiagonalRotation %then %do;
                %let _respAx = &_respAx = diagonal;
            %end;
            %else %do;
                %let _respAx = &_respAx = vertical;
            %end;
        %end;
        %__code(&_respAx)
    %end;

    /*--Category Reference Line--*/
    %if &catRefLine=1 %then %do;
        %let _catRefL = refline;
        %if %qupcase(&category_1_type) = CHARACTER %then %do;
            /* Apply any associated character format to the raw ref line value. */
            %if &category_1_format NE %then %do;
                %let catRefLineLevel = %qsysfunc(putc(&catRefLineLevel, &category_1_format));
            %end;
            %let _catRefL = &_catRefL %qsysfunc(quote(%qtrim(&catRefLineLevel)));
        %end;
        %else %do;
            /* Apply any associated numeric format to the raw ref line value. */
            %if &category_1_format NE %then %do;
                %let catRefLineLevel = %qsysfunc(quote(%qleft(%qsysfunc(putn(&catRefLineLevel, &category_1_format)))));
            %end;
            %let _catRefL = &_catRefL &catRefLineLevel;
        %end;
        %let _catRefL = &_catRefL /;
        %if &boxOrient=vertical %then %do;
            %let _catRefL = &_catRefL axis=x;
        %end;
        %else %do;
            %let _catRefL = &_catRefL axis=y;
        %end;
        %let _catRefL = &_catRefL lineattrs=(thickness=2 color=blue);
        %if &catRefLineOffset NE zero %then %do;
            %if &catRefLineOffset = minusZeroPtFive %then %do;
                %let _catRefL = &_catRefL discreteoffset=-0.5;
            %end;
            %else %if &catRefLineOffset = minusZeroPtTwoFive %then %do;
                %let _catRefL = &_catRefL discreteoffset=-0.25;
            %end;
            %else %if &catRefLineOffset = zeroPtTwoFive %then %do;
                %let _catRefL = &_catRefL discreteoffset=0.25;
            %end;
            %else %do;
                %let _catRefL = &_catRefL discreteoffset=0.5;
            %end;
        %end;
        %let _catRefL = &_catRefL label;
        %if &catRefLabel=catRefCustom %then %do;
            %let _catRefL = &_catRefL = %sysfunc(quote(&catRefCustomLabel));
        %end;
        %let _catRefL = &_catRefL labelattrs=(color=blue);
        %__code(&_catRefL)
    %end;

    /*--Response Reference Line--*/
    %if &respRefLine=1 %then %do;
        %let _respRefL = refline &respRefLineValue /;
        %if &boxOrient=vertical %then %do;
            %let _respRefL = &_respRefL axis=y;
        %end;
        %else %do;
            %let _respRefL = &_respRefL axis=x;
        %end;
        %let _respRefL = &_respRefL lineattrs=(thickness=2 color=green);
        %let _respRefL = &_respRefL label;
        %if &respRefLabel=respRefCustom %then %do;
            %let _respRefL = &_respRefL = %sysfunc(quote(&respRefCustomLabel));
        %end;
        %let _respRefL = &_respRefL labelattrs=(color=green);
        %__code(&_respRefL)
    %end;

    /*--Legend Settings--*/
    %if &group NE AND &legendLoc=inside %then %do;
        %__code(keylegend / location=&legendLoc)
    %end;
    %__code(run)

    /*--Clean up--*/
    %__code(ods graphics / reset)
    %if &titleString NE %then %do;
        %__code(title)
    %end;

    %if &footnoteString NE OR (&dataSource_WhereClause NE AND &includeAsFootnote=1) %then %do;
        %if &dataSource_WhereClause NE AND &includeAsFootnote=1 %then %do;
            %__code(footnote)
        %end;
        %if &footnoteString NE %then %do;
            %__code(footnote2)
        %end;
    %end;

    %if &byVar NE %then %do;
        %__code(proc datasets library=WORK noprint)
        %__code(delete _BoxPlotTaskData)
        %__code(run)
    %end;

%mend runStep;

/* ************************************************************************* */
/* Main entry point: All the work is done in the macro. */
%let __locallyDefinedEntryPointMacro = 0;
%if %sysmacexist(__entryPoint) = 0 %then %do;
    %let __locallyDefinedEntryPointMacro = 1;
    %macro __entryPoint();
        %runStep()
    %mend __entryPoint;
%end;

options mprint;
%__entryPoint()

/* ************************************************************************* */
/* Tidy up macros and macro variables that have been defined. */
%sysmacdelete __formatLabel;
%sysmacdelete __tranmsg;

/* If we created a local __entryPoint macro, remove it. */
%if &__locallyDefinedEntryPointMacro = 1 %then %do;
    %sysmacdelete __entryPoint;
%end;
%symdel __locallyDefinedEntryPointMacro;

/* If we created a local __processErrors macro, remove it. */
%if &__locallyDefinedProcErrsMacro = 1 %then %do;
    %sysmacdelete __processErrors;
%end;
%symdel __locallyDefinedProcErrsMacro;

/* If we created a local __code macro, remove it. */
%if &__locallyDefinedCodeMacro = 1 %then %do;
    %sysmacdelete __code;
%end;
%symdel __locallyDefinedCodeMacro;

/* SAS code provided in template section of Custom Step - END */

/* region: Generated macro cleanup */

/* Cleanup macros and macro variables - BEGIN */
/* Delete macro variables created in this step */

%_flw_del_macro_vars( boxColor );
%_flw_del_macro_vars( boxOrient );
%_flw_del_macro_vars( boxSkin );
%_flw_del_macro_vars( boxWidth );
%_flw_del_macro_vars( boxWidthGrp );
%_flw_del_macro_vars( byVar byVar_count );
%_flw_del_macro_vars( capShape );
%_flw_del_macro_vars( catLabel );
%_flw_del_macro_vars( catLabelRotation );
%_flw_del_macro_vars( catRefCustomLabel );
%_flw_del_macro_vars( catRefLabel );
%_flw_del_macro_vars( catRefLine );
%_flw_del_macro_vars( catRefLineLevel );
%_flw_del_macro_vars( catRefLineOffset );
%_flw_del_macro_vars( catReverse );
%_flw_del_macro_vars( catTickRotate );
%_flw_del_macro_vars( category category_count category_1_format category_1_informat category_1_label category_1_name
                  category_1_name_base category_1_rawlength category_1_type );
%_flw_del_macro_vars( cmHeight );
%_flw_del_macro_vars( cmWidth );
%_flw_del_macro_vars( dataSource dataSource_engine dataSource_label dataSource_lib dataSource_name dataSource_name_base
                  dataSource_type );
%_flw_del_macro_vars( dataSource_WhereClause );
%_flw_del_macro_vars( dimType );
%_flw_del_macro_vars( displayCatLabel );
%_flw_del_macro_vars( displayRespLabel );
%_flw_del_macro_vars( errorLabel_analysisAxis );
%_flw_del_macro_vars( errorLabel_analysisVar );
%_flw_del_macro_vars( errorLabel_boxes );
%_flw_del_macro_vars( errorLabel_fontSize );
%_flw_del_macro_vars( errorLabel_footnote );
%_flw_del_macro_vars( errorLabel_inputData );
%_flw_del_macro_vars( errorLabel_stepName );
%_flw_del_macro_vars( errorLabel_title );
%_flw_del_macro_vars( errorLabel_width );
%_flw_del_macro_vars( error_catLabelRequired );
%_flw_del_macro_vars( error_catRefLabelRequired );
%_flw_del_macro_vars( error_catRefValueRequired );
%_flw_del_macro_vars( error_cmHeightInvalidRange );
%_flw_del_macro_vars( error_cmWidthInvalidRange );
%_flw_del_macro_vars( error_errorsInStep );
%_flw_del_macro_vars( error_inchHeightInvalidRange );
%_flw_del_macro_vars( error_inchWidthInvalidRange );
%_flw_del_macro_vars( error_integerInRange2 );
%_flw_del_macro_vars( error_maxValueRequired );
%_flw_del_macro_vars( error_minValueRequired );
%_flw_del_macro_vars( error_numberInRange2 );
%_flw_del_macro_vars( error_pixelHeightInvalidRange );
%_flw_del_macro_vars( error_pixelWidthInvalidRange );
%_flw_del_macro_vars( error_resLabelRequired );
%_flw_del_macro_vars( error_resRefLabelRequired );
%_flw_del_macro_vars( error_resRefValueRequired );
%_flw_del_macro_vars( error_respAxisMaxLtMin );
%_flw_del_macro_vars( error_tableInfoIncomplete );
%_flw_del_macro_vars( error_variableRequired );
%_flw_del_macro_vars( fillTrans );
%_flw_del_macro_vars( footnoteSize );
%_flw_del_macro_vars( footnoteString );
%_flw_del_macro_vars( footnote_whereFootnote );
%_flw_del_macro_vars( group group_count );
%_flw_del_macro_vars( groupOrder );
%_flw_del_macro_vars( inchHeight );
%_flw_del_macro_vars( inchWidth );
%_flw_del_macro_vars( includeAsFootnote );
%_flw_del_macro_vars( legendLoc );
%_flw_del_macro_vars( logAxis );
%_flw_del_macro_vars( logBaseCombo );
%_flw_del_macro_vars( notches );
%_flw_del_macro_vars( pixelHeight );
%_flw_del_macro_vars( pixelWidth );
%_flw_del_macro_vars( respAxisMax );
%_flw_del_macro_vars( respAxisMaxValue );
%_flw_del_macro_vars( respAxisMin );
%_flw_del_macro_vars( respAxisMinValue );
%_flw_del_macro_vars( respLabel );
%_flw_del_macro_vars( respLabelRotation );
%_flw_del_macro_vars( respRefCustomLabel );
%_flw_del_macro_vars( respRefLabel );
%_flw_del_macro_vars( respRefLine );
%_flw_del_macro_vars( respRefLineValue );
%_flw_del_macro_vars( respTickRotate );
%_flw_del_macro_vars( response response_count response_1_format response_1_informat response_1_label response_1_name
                  response_1_name_base response_1_rawlength response_1_type );
%_flw_del_macro_vars( setColor );
%_flw_del_macro_vars( showRespGrid );
%_flw_del_macro_vars( sortByData );
%_flw_del_macro_vars( titleSize );
%_flw_del_macro_vars( titleString );
%_flw_del_macro_vars( weight weight_count );
/* Delete macros defined in this step */
%_flw_del_macros(_flw_get_column_list _flw_del_macro_vars);

/* Cleanup macros and macro variables - END */

%sysmacdelete _flw_del_macros;

/* endregion */


/* region: Generated step cleanup for Box Plot */
%_flw_action_end(id-1751183256837-39171, , , );
/* endregion */

/* region: Generated flow cleanup */
%sysmacdelete _flw_action_start;
%sysmacdelete _flw_action_end;
/* endregion */
/* region: Generated postamble */

/* Close ODS destinations */
&graphterm; ;*';*";*/;run;quit;
quit;run;
ods html5 (id=web) close;
ods listing close;
%if %sysfunc(fileref(_gsfname)) lt 0 %then %do;
    filename _gsfname clear;
%end;

/* endregion */


